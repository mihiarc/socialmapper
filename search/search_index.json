{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SocialMapper: Explore Community Connections","text":"<p>SocialMapper is an open-source Python toolkit that helps you understand how people connect with the important places in their community. Imagine taking a key spot like your local shopping center or school and seeing exactly what areas are within a certain travel time \u2013 whether it's a quick walk or a longer drive. SocialMapper does just that.</p> <p>But it doesn't stop at travel time. SocialMapper also shows you the characteristics of the people who live within these accessible areas, like how many people live there and what the average income is. This helps you see who can easily reach vital community resources and identify any gaps in access.</p> <p>Whether you're looking at bustling city neighborhoods or more spread-out rural areas, SocialMapper provides clear insights for making communities better, planning services, and ensuring everyone has good access to the places that matter.</p>"},{"location":"#quick-start","title":"\ud83d\ude80 Quick Start","text":"<p>Install with pip: <pre><code>pip install socialmapper\n</code></pre></p> <p>Basic usage: <pre><code>from socialmapper import run_socialmapper\n\n# Analyze library accessibility in your city\nresults = run_socialmapper(\n    geocode_area=\"Chicago\",\n    state=\"IL\",\n    poi_type=\"amenity\",\n    poi_name=\"library\",\n    travel_time=15,\n    census_variables=[\"total_population\", \"median_household_income\"]\n)\n</code></pre></p>"},{"location":"#key-features","title":"\ud83c\udfaf Key Features","text":""},{"location":"#core-analysis","title":"\ud83d\uddfa\ufe0f Core Analysis","text":"<ul> <li>Address Geocoding System - Production-ready address lookup with multiple providers</li> <li>Travel Time Analysis - Generate isochrones showing reachable areas</li> <li>Demographic Integration - Census data analysis for community characteristics  </li> <li>Point of Interest Discovery - Find libraries, schools, healthcare facilities</li> <li>Static Map Generation - Create publication-ready visualizations</li> </ul>"},{"location":"#developer-tools","title":"\ud83d\udee0\ufe0f Developer Tools","text":"<ul> <li>Python API - Full programmatic access</li> <li>Command Line Interface - Easy scripting and automation</li> <li>OSMnx Integration - Advanced network analysis</li> </ul>"},{"location":"#documentation-sections","title":"\ud83d\udcda Documentation Sections","text":""},{"location":"#getting-started","title":"\ud83d\ude80 Getting Started","text":"<ul> <li>Installation Guide - Set up SocialMapper</li> <li>Quick Start Tutorial - Your first analysis</li> <li>Demo Instructions - Interactive demonstrations</li> </ul>"},{"location":"#user-guide","title":"\ud83d\udcd6 User Guide","text":"<ul> <li>Configuration - Customize your analysis</li> <li>Data Sources - Understanding input data</li> <li>Architecture Overview - System design and components</li> </ul>"},{"location":"#features-in-detail","title":"\ud83c\udfaf Features in Detail","text":"<ul> <li>Address Geocoding - Modern address lookup system</li> <li>OSMnx Integration - Advanced network analysis capabilities</li> </ul>"},{"location":"#development","title":"\ud83d\udd27 Development","text":"<ul> <li>Contributing Guide - Join the project</li> <li>Architecture Details - Technical design</li> <li>API Reference - Complete function documentation</li> </ul>"},{"location":"#whats-new","title":"\ud83c\udf1f What's New","text":""},{"location":"#latest-release-features","title":"Latest Release Features","text":"<ul> <li>\ud83c\udfd7\ufe0f Streamlined Architecture - Focused on core demographic analysis</li> <li>\ud83d\udccd Enhanced Geocoding - Production-ready address system</li> <li>\u26a1 Performance Improvements - 17x faster processing with optimized neighbor system</li> <li>\ud83c\udfa8 Modern UI - Rich terminal output and better visualization</li> <li>\ud83d\udcca Enhanced Data Export - Improved CSV and GeoJSON output formats</li> </ul> <p>See the Changelog for complete release history.</p>"},{"location":"#use-cases","title":"\ud83c\udfaf Use Cases","text":""},{"location":"#urban-planning","title":"Urban Planning","text":"<ul> <li>Service Accessibility - Analyze access to public facilities</li> <li>Transportation Planning - Understand travel patterns</li> <li>Community Impact Assessment - Measure development effects</li> </ul>"},{"location":"#public-health-policy","title":"Public Health &amp; Policy","text":"<ul> <li>Healthcare Access - Map medical facility coverage</li> <li>Food Security - Analyze grocery store accessibility  </li> <li>Educational Equity - Study school access patterns</li> </ul>"},{"location":"#research-analysis","title":"Research &amp; Analysis","text":"<ul> <li>Demographic Studies - Population characteristics analysis</li> <li>Accessibility Analysis - Measure access to community resources</li> <li>Social Equity - Identify service gaps and opportunities</li> </ul>"},{"location":"#try-it-now","title":"\ud83d\ude80 Try It Now","text":"Command LinePython APIData Export <pre><code># Install SocialMapper\npip install socialmapper\n\n# Run analysis\nsocialmapper --poi --geocode-area \"Seattle\" --state \"WA\" \\\n  --poi-type \"amenity\" --poi-name \"library\" --travel-time 15\n</code></pre> <pre><code>from socialmapper import run_socialmapper\n\n# Analyze community access\nresults = run_socialmapper(\n    geocode_area=\"Portland\",\n    state=\"OR\", \n    poi_type=\"amenity\",\n    poi_name=\"school\",\n    travel_time=20\n)\n</code></pre> <pre><code># Export results to CSV and maps\nsocialmapper --poi --geocode-area \"Seattle\" --state \"WA\" \\\n  --poi-type \"amenity\" --poi-name \"library\" --travel-time 15 \\\n  --export-csv --export-maps\n</code></pre>"},{"location":"#community-support","title":"\ud83e\udd1d Community &amp; Support","text":"<ul> <li>GitHub Repository - Source code and issues</li> <li>PyPI Package - Package downloads</li> <li>Documentation - This site</li> <li>Examples - Sample workflows and use cases</li> </ul>"},{"location":"#future-vision","title":"\ud83d\udd2e Future Vision","text":"<p>SocialMapper is focused on becoming the premier tool for demographic accessibility analysis with plans for:</p> <ul> <li>\ud83c\udf0d Environmental Integration - Natural area accessibility</li> <li>\ud83d\ude8a Multi-modal Transportation - Enhanced transit, walking, cycling analysis  </li> <li>\ud83d\udcca Enhanced Analytics - More sophisticated demographic analysis</li> <li>\ud83c\udf10 Global Expansion - International data sources and census systems</li> </ul> <p>Ready to explore your community? Start with our Getting Started Guide or try the Command Line Interface! </p>"},{"location":"ADDRESS_GEOCODING/","title":"\ud83d\udccd Address Geocoding in SocialMapper","text":""},{"location":"ADDRESS_GEOCODING/#overview","title":"Overview","text":"<p>Address geocoding is a core feature in SocialMapper that converts human-readable addresses into geographic coordinates (latitude/longitude). This enables you to analyze custom locations beyond what's available in OpenStreetMap, such as:</p> <ul> <li>Your organization's facilities</li> <li>Client locations</li> <li>Community resources not in OSM</li> <li>Historical addresses</li> <li>Survey respondent locations</li> </ul>"},{"location":"ADDRESS_GEOCODING/#how-it-works-with-socialmapper","title":"How It Works with SocialMapper","text":"<p>The geocoding system seamlessly integrates into SocialMapper's analysis workflow:</p> <ol> <li>Input addresses via CSV file or API</li> <li>Convert to coordinates using multiple geocoding providers</li> <li>Generate isochrones around each location</li> <li>Analyze demographics within travel time areas</li> <li>Export results with full geographic context</li> </ol>"},{"location":"ADDRESS_GEOCODING/#example-workflow","title":"Example Workflow","text":"<pre><code>from socialmapper import run_socialmapper\n\n# Analyze accessibility from your custom locations\nresults = run_socialmapper(\n    addresses_path=\"my_facilities.csv\",  # Your addresses\n    travel_time=15,                      # 15-minute isochrones\n    census_variables=[\"total_population\", \"median_income\"],\n    export_maps=True\n)\n</code></pre>"},{"location":"ADDRESS_GEOCODING/#key-features","title":"Key Features","text":""},{"location":"ADDRESS_GEOCODING/#multiple-provider-support","title":"\ud83d\udd04 Multiple Provider Support","text":"<ul> <li>OpenStreetMap Nominatim - Free, global coverage</li> <li>US Census Geocoder - High accuracy for US addresses</li> <li>Extensible to add Google Maps, HERE, Mapbox</li> </ul>"},{"location":"ADDRESS_GEOCODING/#high-performance","title":"\u26a1 High Performance","text":"<ul> <li>Intelligent caching - 96% storage reduction with Parquet</li> <li>Batch processing - Handle thousands of addresses efficiently</li> <li>Automatic fallback - Try multiple providers for best results</li> </ul>"},{"location":"ADDRESS_GEOCODING/#quality-assurance","title":"\ud83c\udfaf Quality Assurance","text":"<ul> <li>Quality scoring - EXACT, INTERPOLATED, CENTROID, APPROXIMATE</li> <li>Validation - Ensure coordinates are within expected bounds</li> <li>Geographic enrichment - Add state, county, tract, block group</li> </ul>"},{"location":"ADDRESS_GEOCODING/#quick-start","title":"\ud83d\ude80 Quick Start","text":""},{"location":"ADDRESS_GEOCODING/#basic-usage","title":"Basic Usage","text":"<pre><code>from socialmapper.geocoding import geocode_address\n\n# Simple address geocoding\nresult = geocode_address(\"123 Main St, Anytown, USA\")\nif result.success:\n    print(f\"Location: {result.latitude}, {result.longitude}\")\n    print(f\"Quality: {result.quality.value}\")\n</code></pre>"},{"location":"ADDRESS_GEOCODING/#batch-processing","title":"Batch Processing","text":"<pre><code>from socialmapper.geocoding import geocode_addresses\n\n# Geocode multiple addresses\naddresses = [\n    \"123 Main St, City, State\",\n    \"456 Oak Ave, Town, State\",\n    \"789 Elm Blvd, Village, State\"\n]\n\nresults = geocode_addresses(addresses, progress=True)\nsuccessful = [r for r in results if r.success]\nprint(f\"Geocoded {len(successful)} of {len(addresses)} addresses\")\n</code></pre>"},{"location":"ADDRESS_GEOCODING/#csv-file-input","title":"CSV File Input","text":"<p>Create a CSV file with your addresses: <pre><code>name,address,city,state,zip\nMain Library,123 Main St,Springfield,IL,62701\nBranch Library,456 Oak Ave,Springfield,IL,62702\nCommunity Center,789 Elm St,Springfield,IL,62703\n</code></pre></p> <p>Then use with SocialMapper: <pre><code>socialmapper analyze --addresses-file my_locations.csv --travel-time 15\n</code></pre></p>"},{"location":"ADDRESS_GEOCODING/#architecture","title":"\ud83c\udfd7\ufe0f Architecture","text":"<p>The geocoding system follows a modular design:</p> <pre><code>socialmapper/geocoding/\n\u251c\u2500\u2500 __init__.py           # Public API\n\u251c\u2500\u2500 engine.py             # Core orchestration\n\u251c\u2500\u2500 providers.py          # Provider implementations\n\u2514\u2500\u2500 cache.py             # Caching system\n</code></pre>"},{"location":"ADDRESS_GEOCODING/#key-components","title":"Key Components","text":"<ol> <li>AddressGeocodingEngine - Orchestrates the geocoding process</li> <li>GeocodingProviders - Implement specific geocoding services</li> <li>AddressCache - High-performance caching layer</li> <li>Quality Validation - Ensures result accuracy</li> </ol>"},{"location":"ADDRESS_GEOCODING/#configuration","title":"\u2699\ufe0f Configuration","text":""},{"location":"ADDRESS_GEOCODING/#basic-configuration","title":"Basic Configuration","text":"<pre><code>from socialmapper.geocoding import GeocodingConfig, AddressProvider\n\nconfig = GeocodingConfig(\n    primary_provider=AddressProvider.NOMINATIM,\n    fallback_providers=[AddressProvider.CENSUS],\n    enable_cache=True,\n    min_quality_threshold=\"INTERPOLATED\"\n)\n</code></pre>"},{"location":"ADDRESS_GEOCODING/#advanced-options","title":"Advanced Options","text":"<pre><code>config = GeocodingConfig(\n    # Performance\n    timeout_seconds=10,\n    max_retries=3,\n    batch_size=100,\n\n    # Quality\n    min_quality_threshold=\"EXACT\",\n    require_country_match=True,\n\n    # Caching\n    cache_ttl_hours=168,  # 1 week\n    cache_max_size=10000\n)\n</code></pre>"},{"location":"ADDRESS_GEOCODING/#quality-levels","title":"\ud83c\udfaf Quality Levels","text":"Quality Description Use Case EXACT Rooftop/exact match Precise analysis INTERPOLATED Street-level Neighborhood studies CENTROID ZIP/city center Regional analysis APPROXIMATE Low precision Exploratory work"},{"location":"ADDRESS_GEOCODING/#integration-examples","title":"\ud83d\udcca Integration Examples","text":""},{"location":"ADDRESS_GEOCODING/#with-travel-time-analysis","title":"With Travel Time Analysis","text":"<pre><code># Geocode addresses and analyze accessibility\nfrom socialmapper import run_socialmapper\n\nresults = run_socialmapper(\n    addresses_path=\"health_clinics.csv\",\n    travel_time=20,\n    travel_mode=\"drive\",\n    census_variables=[\"total_population\", \"percent_uninsured\"]\n)\n\n# Results include full demographic analysis for each clinic's service area\n</code></pre>"},{"location":"ADDRESS_GEOCODING/#with-custom-poi-data","title":"With Custom POI Data","text":"<pre><code>from socialmapper.geocoding import addresses_to_poi_format\n\n# Convert addresses to POI format\naddresses = [\n    {\"name\": \"Clinic A\", \"address\": \"123 Main St, City, State\"},\n    {\"name\": \"Clinic B\", \"address\": \"456 Oak Ave, Town, State\"}\n]\n\npoi_data = addresses_to_poi_format(addresses)\n\n# Use with standard SocialMapper workflow\nfrom socialmapper import run_socialmapper\nresults = run_socialmapper(\n    custom_coords_data=poi_data,\n    travel_time=15\n)\n</code></pre>"},{"location":"ADDRESS_GEOCODING/#caching-system","title":"\ud83d\udcbe Caching System","text":"<p>The geocoding cache dramatically improves performance:</p> <ul> <li>Persistent storage - Results saved between sessions</li> <li>Automatic deduplication - Same address never geocoded twice</li> <li>TTL expiration - Configurable cache lifetime</li> <li>Compact format - Parquet files use 96% less space than JSON</li> </ul>"},{"location":"ADDRESS_GEOCODING/#cache-location","title":"Cache Location","text":"<pre><code>cache/geocoding/\n\u2514\u2500\u2500 address_cache.parquet\n</code></pre>"},{"location":"ADDRESS_GEOCODING/#troubleshooting","title":"\ud83d\udd27 Troubleshooting","text":""},{"location":"ADDRESS_GEOCODING/#common-issues","title":"Common Issues","text":"<p>\"No results found\" - Check address format and spelling - Try including more details (city, state, ZIP) - Verify internet connection</p> <p>\"Quality below threshold\" - Lower the quality threshold for exploratory analysis - Add more address details for better matches - Try a different provider</p> <p>\"Rate limit exceeded\" - Enable caching to reduce API calls - Reduce batch size - Add delays between requests</p>"},{"location":"ADDRESS_GEOCODING/#debug-mode","title":"Debug Mode","text":"<pre><code>import logging\nlogging.getLogger('socialmapper.geocoding').setLevel(logging.DEBUG)\n\n# Now geocoding will show detailed progress\nresult = geocode_address(\"123 Main St\")\n</code></pre>"},{"location":"ADDRESS_GEOCODING/#best-practices","title":"\ud83d\udccb Best Practices","text":"<ol> <li>Always use caching - Reduces API calls and improves speed</li> <li>Batch similar addresses - Group by city/state for efficiency</li> <li>Set appropriate quality thresholds - EXACT for precise analysis, CENTROID for regional</li> <li>Include full addresses - More details = better results</li> <li>Handle failures gracefully - Some addresses may not geocode</li> </ol>"},{"location":"ADDRESS_GEOCODING/#complete-example","title":"\ud83c\udf93 Complete Example","text":"<p>Here's a full workflow using address geocoding:</p> <pre><code>from socialmapper import run_socialmapper\nfrom socialmapper.geocoding import GeocodingConfig, AddressProvider\n\n# Configure geocoding\ngeocoding_config = GeocodingConfig(\n    primary_provider=AddressProvider.CENSUS,  # Best for US addresses\n    enable_cache=True,\n    min_quality_threshold=\"INTERPOLATED\"\n)\n\n# Run analysis on your facilities\nresults = run_socialmapper(\n    addresses_path=\"our_facilities.csv\",\n    travel_time=15,\n    travel_mode=\"walk\",\n    census_variables=[\n        \"total_population\",\n        \"median_age\", \n        \"percent_poverty\",\n        \"percent_without_vehicle\"\n    ],\n    geocoding_config=geocoding_config,\n    export_csv=True,\n    export_maps=True\n)\n\n# Examine results\nprint(f\"Successfully geocoded {results['geocoding_stats']['success_count']} addresses\")\nprint(f\"Population within walking distance: {results['total_population']:,}\")\n</code></pre>"},{"location":"ADDRESS_GEOCODING/#future-enhancements","title":"\ud83d\udd2e Future Enhancements","text":"<ul> <li>Google Maps and HERE provider support</li> <li>International address formats</li> <li>Fuzzy matching for misspelled addresses</li> <li>Address standardization and validation</li> <li>Async processing for large batches</li> </ul> <p>The address geocoding system in SocialMapper provides reliable, cached, and quality-assured location lookup to enable demographic analysis of any custom location.</p>"},{"location":"API_MODERNIZATION_RECOMMENDATIONS/","title":"SocialMapper API Modernization Recommendations","text":""},{"location":"API_MODERNIZATION_RECOMMENDATIONS/#1-current-api-design-analysis","title":"1. Current API Design Analysis","text":""},{"location":"API_MODERNIZATION_RECOMMENDATIONS/#current-state-overview","title":"Current State Overview","text":"<p>The SocialMapper API currently has several design challenges:</p>"},{"location":"API_MODERNIZATION_RECOMMENDATIONS/#function-signature-complexity","title":"Function Signature Complexity","text":"<p>The main entry point <code>run_socialmapper()</code> has 22 parameters, making it difficult to use and maintain: <pre><code>def run_socialmapper(\n    run_config: Optional[RunConfig] = None,\n    *,\n    geocode_area: Optional[str] = None,\n    state: Optional[str] = None,\n    city: Optional[str] = None,\n    poi_type: Optional[str] = None,\n    poi_name: Optional[str] = None,\n    additional_tags: Optional[Dict] = None,\n    travel_time: int = 15,\n    geographic_level: str = \"block-group\",\n    census_variables: List[str] | None = None,\n    api_key: Optional[str] = None,\n    output_dir: str = \"output\",\n    custom_coords_path: Optional[str] = None,\n    export_csv: bool = True,\n    export_maps: bool = False,\n    export_isochrones: bool = False,\n    use_interactive_maps: bool = True,\n    map_backend: str = \"plotly\",\n    name_field: Optional[str] = None,\n    type_field: Optional[str] = None,\n    max_poi_count: Optional[int] = None\n) -&gt; Dict[str, Any]:\n</code></pre></p>"},{"location":"API_MODERNIZATION_RECOMMENDATIONS/#configuration-models","title":"Configuration Models","text":"<ul> <li>Two separate config models: <code>RunConfig</code> (minimal) and <code>PipelineConfig</code> (comprehensive)</li> <li>No clear separation between required and optional parameters</li> <li>Missing validation for mutually exclusive options</li> </ul>"},{"location":"API_MODERNIZATION_RECOMMENDATIONS/#return-types","title":"Return Types","text":"<ul> <li>Returns untyped <code>Dict[str, Any]</code></li> <li>No structured error responses</li> <li>No way to distinguish between success and partial success</li> </ul>"},{"location":"API_MODERNIZATION_RECOMMENDATIONS/#error-handling","title":"Error Handling","text":"<ul> <li>Basic exception propagation without structured error types</li> <li>No result types (Ok/Error pattern)</li> <li>Limited recovery mechanisms</li> </ul>"},{"location":"API_MODERNIZATION_RECOMMENDATIONS/#async-support","title":"Async Support","text":"<ul> <li>Some async patterns exist (AsyncRateLimitedClient) but not exposed in main API</li> <li>Network operations are synchronous at the API level</li> <li>No streaming support for large datasets</li> </ul>"},{"location":"API_MODERNIZATION_RECOMMENDATIONS/#2-modern-api-design-patterns-recommendations","title":"2. Modern API Design Patterns Recommendations","text":""},{"location":"API_MODERNIZATION_RECOMMENDATIONS/#21-builder-pattern-for-configuration","title":"2.1 Builder Pattern for Configuration","text":"<pre><code>from typing import Self, Optional, List, Dict\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nclass GeographicLevel(Enum):\n    BLOCK_GROUP = \"block-group\"\n    ZCTA = \"zcta\"\n    TRACT = \"tract\"\n    COUNTY = \"county\"\n\nclass MapBackend(Enum):\n    PLOTLY = \"plotly\"\n    MATPLOTLIB = \"matplotlib\"\n    FOLIUM = \"folium\"\n\n@dataclass\nclass SocialMapperBuilder:\n    \"\"\"Fluent builder for SocialMapper configuration.\"\"\"\n\n    # POI Configuration\n    _poi_source: Optional['POISource'] = None\n    _travel_time: int = 15\n    _max_poi_count: Optional[int] = None\n\n    # Geographic Configuration\n    _geographic_level: GeographicLevel = GeographicLevel.BLOCK_GROUP\n    _census_variables: List[str] = field(default_factory=lambda: [\"total_population\"])\n    _api_key: Optional[str] = None\n\n    # Output Configuration\n    _output_dir: str = \"output\"\n    _exports: Dict[str, bool] = field(default_factory=lambda: {\n        \"csv\": True,\n        \"maps\": False,\n        \"isochrones\": False,\n        \"interactive\": True\n    })\n    _map_backend: MapBackend = MapBackend.PLOTLY\n\n    def with_osm_pois(self, \n                      area: str,\n                      state: str,\n                      poi_type: str,\n                      poi_name: str,\n                      additional_tags: Optional[Dict] = None) -&gt; Self:\n        \"\"\"Configure OpenStreetMap POI source.\"\"\"\n        self._poi_source = OSMPOISource(\n            area=area,\n            state=state,\n            poi_type=poi_type,\n            poi_name=poi_name,\n            additional_tags=additional_tags or {}\n        )\n        return self\n\n    def with_custom_pois(self,\n                        file_path: str,\n                        name_field: Optional[str] = None,\n                        type_field: Optional[str] = None) -&gt; Self:\n        \"\"\"Configure custom POI source from file.\"\"\"\n        self._poi_source = CustomPOISource(\n            file_path=file_path,\n            name_field=name_field,\n            type_field=type_field\n        )\n        return self\n\n    def with_travel_time(self, minutes: int) -&gt; Self:\n        \"\"\"Set travel time for isochrones.\"\"\"\n        if not 1 &lt;= minutes &lt;= 120:\n            raise ValueError(\"Travel time must be between 1 and 120 minutes\")\n        self._travel_time = minutes\n        return self\n\n    def with_census_variables(self, *variables: str) -&gt; Self:\n        \"\"\"Add census variables to retrieve.\"\"\"\n        self._census_variables.extend(variables)\n        return self\n\n    def with_api_key(self, key: str) -&gt; Self:\n        \"\"\"Set Census API key.\"\"\"\n        self._api_key = key\n        return self\n\n    def with_output_dir(self, path: str) -&gt; Self:\n        \"\"\"Set output directory.\"\"\"\n        self._output_dir = path\n        return self\n\n    def enable_csv_export(self, enabled: bool = True) -&gt; Self:\n        \"\"\"Enable/disable CSV export.\"\"\"\n        self._exports[\"csv\"] = enabled\n        return self\n\n    def enable_map_export(self, enabled: bool = True) -&gt; Self:\n        \"\"\"Enable/disable map generation.\"\"\"\n        self._exports[\"maps\"] = enabled\n        return self\n\n    def enable_isochrone_export(self, enabled: bool = True) -&gt; Self:\n        \"\"\"Enable/disable isochrone export.\"\"\"\n        self._exports[\"isochrones\"] = enabled\n        return self\n\n    def with_map_backend(self, backend: MapBackend) -&gt; Self:\n        \"\"\"Set map rendering backend.\"\"\"\n        self._map_backend = backend\n        return self\n\n    def limit_poi_count(self, max_count: int) -&gt; Self:\n        \"\"\"Limit number of POIs to process.\"\"\"\n        self._max_poi_count = max_count\n        return self\n\n    def build(self) -&gt; 'SocialMapperConfig':\n        \"\"\"Build and validate the configuration.\"\"\"\n        if self._poi_source is None:\n            raise ValueError(\"POI source must be configured\")\n\n        return SocialMapperConfig(\n            poi_source=self._poi_source,\n            travel_time=self._travel_time,\n            max_poi_count=self._max_poi_count,\n            geographic_level=self._geographic_level,\n            census_variables=self._census_variables,\n            api_key=self._api_key,\n            output_dir=self._output_dir,\n            exports=self._exports,\n            map_backend=self._map_backend\n        )\n\n# Usage example:\nconfig = (SocialMapperBuilder()\n    .with_osm_pois(\n        area=\"San Francisco\",\n        state=\"CA\",\n        poi_type=\"amenity\",\n        poi_name=\"library\"\n    )\n    .with_travel_time(20)\n    .with_census_variables(\"median_income\", \"education_bachelors_plus\")\n    .enable_map_export()\n    .enable_isochrone_export()\n    .build()\n)\n</code></pre>"},{"location":"API_MODERNIZATION_RECOMMENDATIONS/#22-asyncawait-support","title":"2.2 Async/Await Support","text":"<pre><code>import asyncio\nfrom typing import AsyncIterator, Optional\nfrom dataclasses import dataclass\n\n@dataclass\nclass AsyncSocialMapper:\n    \"\"\"Async version of SocialMapper for better I/O performance.\"\"\"\n\n    def __init__(self, config: SocialMapperConfig):\n        self.config = config\n        self._session: Optional[httpx.AsyncClient] = None\n\n    async def __aenter__(self):\n        \"\"\"Context manager entry.\"\"\"\n        self._session = httpx.AsyncClient(\n            timeout=30.0,\n            limits=httpx.Limits(max_keepalive_connections=5)\n        )\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Context manager exit.\"\"\"\n        if self._session:\n            await self._session.aclose()\n\n    async def extract_pois(self) -&gt; AsyncIterator[POI]:\n        \"\"\"Extract POIs asynchronously.\"\"\"\n        if isinstance(self.config.poi_source, OSMPOISource):\n            async for poi in self._extract_osm_pois():\n                yield poi\n        else:\n            # File-based extraction can be synchronous\n            for poi in self._extract_custom_pois():\n                yield poi\n\n    async def _extract_osm_pois(self) -&gt; AsyncIterator[POI]:\n        \"\"\"Extract POIs from OpenStreetMap.\"\"\"\n        # Use async HTTP client for Overpass API\n        query = self._build_overpass_query()\n\n        async with self._session.post(\n            \"https://overpass-api.de/api/interpreter\",\n            data={\"data\": query}\n        ) as response:\n            response.raise_for_status()\n            data = await response.json()\n\n            for element in data.get(\"elements\", []):\n                yield POI.from_osm_element(element)\n\n    async def generate_isochrones(self, pois: List[POI]) -&gt; AsyncIterator[Isochrone]:\n        \"\"\"Generate isochrones concurrently.\"\"\"\n        # Create tasks for concurrent processing\n        tasks = [\n            self._generate_single_isochrone(poi) \n            for poi in pois\n        ]\n\n        # Process with concurrency limit\n        semaphore = asyncio.Semaphore(5)  # Max 5 concurrent requests\n\n        async def bounded_task(task):\n            async with semaphore:\n                return await task\n\n        # Yield results as they complete\n        for coro in asyncio.as_completed([bounded_task(t) for t in tasks]):\n            try:\n                isochrone = await coro\n                yield isochrone\n            except Exception as e:\n                # Log error but continue processing\n                logger.error(f\"Failed to generate isochrone: {e}\")\n\n    async def fetch_census_data(self, \n                               geographic_units: List[GeographicUnit]) -&gt; AsyncIterator[CensusData]:\n        \"\"\"Fetch census data with streaming support.\"\"\"\n        # Batch requests for efficiency\n        batch_size = 50\n\n        for i in range(0, len(geographic_units), batch_size):\n            batch = geographic_units[i:i + batch_size]\n\n            # Create census API request\n            params = self._build_census_params(batch)\n\n            async with self._session.get(\n                \"https://api.census.gov/data/2021/acs/acs5\",\n                params=params\n            ) as response:\n                response.raise_for_status()\n                data = await response.json()\n\n                # Parse and yield census data\n                for row in self._parse_census_response(data):\n                    yield row\n\n# Usage example:\nasync def main():\n    config = (SocialMapperBuilder()\n        .with_osm_pois(\"San Francisco\", \"CA\", \"amenity\", \"library\")\n        .with_census_variables(\"median_income\", \"population\")\n        .build()\n    )\n\n    async with AsyncSocialMapper(config) as mapper:\n        # Extract POIs\n        pois = []\n        async for poi in mapper.extract_pois():\n            pois.append(poi)\n            print(f\"Found POI: {poi.name}\")\n\n        # Generate isochrones concurrently\n        isochrones = []\n        async for isochrone in mapper.generate_isochrones(pois):\n            isochrones.append(isochrone)\n            print(f\"Generated isochrone for: {isochrone.poi.name}\")\n\n        # Stream census data\n        async for census_data in mapper.fetch_census_data(geographic_units):\n            print(f\"Census data: {census_data}\")\n\n# Run async\nasyncio.run(main())\n</code></pre>"},{"location":"API_MODERNIZATION_RECOMMENDATIONS/#23-result-types-okerror-pattern","title":"2.3 Result Types (Ok/Error Pattern)","text":"<pre><code>from typing import Generic, TypeVar, Union, Optional\nfrom dataclasses import dataclass\nfrom abc import ABC, abstractmethod\n\nT = TypeVar('T')\nE = TypeVar('E')\n\nclass Result(ABC, Generic[T, E]):\n    \"\"\"Base class for Result type.\"\"\"\n\n    @abstractmethod\n    def is_ok(self) -&gt; bool:\n        \"\"\"Check if result is Ok.\"\"\"\n        pass\n\n    @abstractmethod\n    def is_err(self) -&gt; bool:\n        \"\"\"Check if result is Error.\"\"\"\n        pass\n\n    @abstractmethod\n    def unwrap(self) -&gt; T:\n        \"\"\"Get the value or raise if error.\"\"\"\n        pass\n\n    @abstractmethod\n    def unwrap_err(self) -&gt; E:\n        \"\"\"Get the error or raise if ok.\"\"\"\n        pass\n\n    @abstractmethod\n    def map(self, func) -&gt; 'Result':\n        \"\"\"Map function over Ok value.\"\"\"\n        pass\n\n    @abstractmethod\n    def map_err(self, func) -&gt; 'Result':\n        \"\"\"Map function over Error value.\"\"\"\n        pass\n\n@dataclass\nclass Ok(Result[T, E]):\n    \"\"\"Success result.\"\"\"\n    value: T\n\n    def is_ok(self) -&gt; bool:\n        return True\n\n    def is_err(self) -&gt; bool:\n        return False\n\n    def unwrap(self) -&gt; T:\n        return self.value\n\n    def unwrap_err(self) -&gt; E:\n        raise ValueError(\"Called unwrap_err on Ok value\")\n\n    def map(self, func):\n        return Ok(func(self.value))\n\n    def map_err(self, func):\n        return self\n\n    def unwrap_or(self, default: T) -&gt; T:\n        return self.value\n\n    def and_then(self, func):\n        \"\"\"Flatmap for Result.\"\"\"\n        return func(self.value)\n\n@dataclass\nclass Err(Result[T, E]):\n    \"\"\"Error result.\"\"\"\n    error: E\n\n    def is_ok(self) -&gt; bool:\n        return False\n\n    def is_err(self) -&gt; bool:\n        return True\n\n    def unwrap(self) -&gt; T:\n        raise ValueError(f\"Called unwrap on Err value: {self.error}\")\n\n    def unwrap_err(self) -&gt; E:\n        return self.error\n\n    def map(self, func):\n        return self\n\n    def map_err(self, func):\n        return Err(func(self.error))\n\n    def unwrap_or(self, default: T) -&gt; T:\n        return default\n\n    def and_then(self, func):\n        return self\n\n# Error types\n@dataclass\nclass SocialMapperError:\n    \"\"\"Base error type for SocialMapper.\"\"\"\n    message: str\n    code: str\n    details: Optional[Dict[str, Any]] = None\n\n@dataclass\nclass ValidationError(SocialMapperError):\n    \"\"\"Input validation error.\"\"\"\n    field: str\n    constraint: str\n\n@dataclass\nclass APIError(SocialMapperError):\n    \"\"\"External API error.\"\"\"\n    service: str\n    status_code: Optional[int] = None\n    retry_after: Optional[int] = None\n\n@dataclass\nclass ProcessingError(SocialMapperError):\n    \"\"\"Processing pipeline error.\"\"\"\n    stage: str\n    cause: Optional[Exception] = None\n\n# Updated API with Result types\nclass SocialMapperAPI:\n    \"\"\"Modern API with Result types.\"\"\"\n\n    def validate_config(self, config: SocialMapperConfig) -&gt; Result[None, ValidationError]:\n        \"\"\"Validate configuration.\"\"\"\n        # Check POI source\n        if config.poi_source is None:\n            return Err(ValidationError(\n                message=\"POI source is required\",\n                code=\"MISSING_POI_SOURCE\",\n                field=\"poi_source\",\n                constraint=\"required\"\n            ))\n\n        # Check travel time\n        if not 1 &lt;= config.travel_time &lt;= 120:\n            return Err(ValidationError(\n                message=\"Travel time must be between 1 and 120 minutes\",\n                code=\"INVALID_TRAVEL_TIME\",\n                field=\"travel_time\",\n                constraint=\"range[1,120]\"\n            ))\n\n        # Check API key if census variables specified\n        if config.census_variables and not config.api_key:\n            return Err(ValidationError(\n                message=\"Census API key required when census variables specified\",\n                code=\"MISSING_API_KEY\",\n                field=\"api_key\",\n                constraint=\"required_with:census_variables\"\n            ))\n\n        return Ok(None)\n\n    def extract_pois(self, config: SocialMapperConfig) -&gt; Result[List[POI], ProcessingError]:\n        \"\"\"Extract POIs with error handling.\"\"\"\n        try:\n            if isinstance(config.poi_source, OSMPOISource):\n                pois = self._extract_osm_pois(config.poi_source)\n            else:\n                pois = self._extract_custom_pois(config.poi_source)\n\n            if not pois:\n                return Err(ProcessingError(\n                    message=\"No POIs found\",\n                    code=\"NO_POIS_FOUND\",\n                    stage=\"extraction\"\n                ))\n\n            return Ok(pois)\n\n        except Exception as e:\n            return Err(ProcessingError(\n                message=f\"Failed to extract POIs: {str(e)}\",\n                code=\"POI_EXTRACTION_FAILED\",\n                stage=\"extraction\",\n                cause=e\n            ))\n\n    def run_pipeline(self, config: SocialMapperConfig) -&gt; Result[PipelineResult, SocialMapperError]:\n        \"\"\"Run complete pipeline with Result type.\"\"\"\n        # Validate configuration\n        validation = self.validate_config(config)\n        if validation.is_err():\n            return validation\n\n        # Extract POIs\n        poi_result = self.extract_pois(config)\n        if poi_result.is_err():\n            return poi_result\n\n        pois = poi_result.unwrap()\n\n        # Continue with pipeline...\n        return Ok(PipelineResult(\n            pois=pois,\n            isochrones=[],\n            census_data={},\n            outputs={}\n        ))\n\n# Usage with error handling\napi = SocialMapperAPI()\nresult = api.run_pipeline(config)\n\nmatch result:\n    case Ok(pipeline_result):\n        print(f\"Success! Found {len(pipeline_result.pois)} POIs\")\n    case Err(ValidationError() as e):\n        print(f\"Validation error: {e.message} (field: {e.field})\")\n    case Err(APIError() as e):\n        print(f\"API error from {e.service}: {e.message}\")\n        if e.retry_after:\n            print(f\"Retry after {e.retry_after} seconds\")\n    case Err(ProcessingError() as e):\n        print(f\"Processing error in {e.stage}: {e.message}\")\n</code></pre>"},{"location":"API_MODERNIZATION_RECOMMENDATIONS/#24-context-managers-for-resource-management","title":"2.4 Context Managers for Resource Management","text":"<pre><code>from contextlib import contextmanager, asynccontextmanager\nfrom typing import Iterator, AsyncIterator\nimport tempfile\nimport shutil\n\nclass SocialMapperSession:\n    \"\"\"Context manager for SocialMapper session with resource management.\"\"\"\n\n    def __init__(self, config: SocialMapperConfig):\n        self.config = config\n        self._temp_dir: Optional[str] = None\n        self._cache_manager: Optional[CacheManager] = None\n        self._http_client: Optional[httpx.Client] = None\n        self._db_connection: Optional[Any] = None\n\n    def __enter__(self) -&gt; 'SocialMapperSession':\n        \"\"\"Initialize resources.\"\"\"\n        # Create temporary directory for intermediate files\n        self._temp_dir = tempfile.mkdtemp(prefix=\"socialmapper_\")\n\n        # Initialize cache manager\n        self._cache_manager = CacheManager(\n            cache_dir=os.path.join(self._temp_dir, \"cache\"),\n            max_size_mb=500\n        )\n\n        # Create HTTP client with connection pooling\n        self._http_client = httpx.Client(\n            timeout=30.0,\n            limits=httpx.Limits(\n                max_keepalive_connections=10,\n                max_connections=20\n            )\n        )\n\n        # Initialize database connection if needed\n        if self.config.use_database:\n            self._db_connection = self._init_database()\n\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Cleanup resources.\"\"\"\n        # Close HTTP client\n        if self._http_client:\n            self._http_client.close()\n\n        # Close database connection\n        if self._db_connection:\n            self._db_connection.close()\n\n        # Save cache statistics\n        if self._cache_manager:\n            self._cache_manager.save_statistics()\n\n        # Clean up temporary directory\n        if self._temp_dir and os.path.exists(self._temp_dir):\n            shutil.rmtree(self._temp_dir)\n\n    @contextmanager\n    def transaction(self) -&gt; Iterator['Transaction']:\n        \"\"\"Create a transaction context.\"\"\"\n        transaction = Transaction(self)\n        try:\n            yield transaction\n            transaction.commit()\n        except Exception:\n            transaction.rollback()\n            raise\n\n    def run_with_progress(self, pipeline: Pipeline) -&gt; PipelineResult:\n        \"\"\"Run pipeline with progress tracking.\"\"\"\n        with self.transaction() as tx:\n            # Setup progress tracking\n            progress = ProgressTracker(total_stages=len(pipeline.stages))\n\n            for stage in pipeline.stages:\n                with progress.stage(stage.name):\n                    result = stage.run(self, tx)\n                    tx.save_checkpoint(stage.name, result)\n\n            return tx.get_result()\n\n# Async context manager\n@asynccontextmanager\nasync def async_socialmapper_session(config: SocialMapperConfig) -&gt; AsyncIterator[AsyncSocialMapperSession]:\n    \"\"\"Async context manager for SocialMapper.\"\"\"\n    session = AsyncSocialMapperSession(config)\n\n    # Initialize async resources\n    session._http_client = httpx.AsyncClient(\n        timeout=30.0,\n        limits=httpx.Limits(max_keepalive_connections=10)\n    )\n\n    try:\n        yield session\n    finally:\n        # Cleanup async resources\n        await session._http_client.aclose()\n        if session._cache_manager:\n            await session._cache_manager.flush()\n\n# Usage examples\n# Synchronous\nwith SocialMapperSession(config) as session:\n    result = session.run_with_progress(pipeline)\n    print(f\"Processed {len(result.pois)} POIs\")\n\n# Asynchronous\nasync with async_socialmapper_session(config) as session:\n    async for poi in session.stream_pois():\n        print(f\"Processing POI: {poi.name}\")\n</code></pre>"},{"location":"API_MODERNIZATION_RECOMMENDATIONS/#25-type-safety-with-generics-and-protocols","title":"2.5 Type Safety with Generics and Protocols","text":"<pre><code>from typing import Protocol, TypeVar, Generic, List, Dict, Any\nfrom abc import abstractmethod\n\nT = TypeVar('T')\nP = TypeVar('P', bound='POIProtocol')\nI = TypeVar('I', bound='IsochroneProtocol')\nC = TypeVar('C', bound='CensusDataProtocol')\n\nclass POIProtocol(Protocol):\n    \"\"\"Protocol for POI objects.\"\"\"\n    name: str\n    latitude: float\n    longitude: float\n    type: str\n\n    def to_dict(self) -&gt; Dict[str, Any]: ...\n    def distance_to(self, other: 'POIProtocol') -&gt; float: ...\n\nclass IsochroneProtocol(Protocol):\n    \"\"\"Protocol for isochrone objects.\"\"\"\n    poi: POIProtocol\n    travel_time: int\n    geometry: Any  # shapely geometry\n\n    def contains_point(self, lat: float, lon: float) -&gt; bool: ...\n    def area_sq_km(self) -&gt; float: ...\n\nclass CensusDataProtocol(Protocol):\n    \"\"\"Protocol for census data objects.\"\"\"\n    geographic_id: str\n    variables: Dict[str, Any]\n\n    def get_variable(self, code: str) -&gt; Any: ...\n    def get_population(self) -&gt; int: ...\n\nclass DataProcessor(Generic[T]):\n    \"\"\"Generic data processor.\"\"\"\n\n    def __init__(self, transformer: Callable[[T], T]):\n        self.transformer = transformer\n\n    def process(self, items: List[T]) -&gt; List[T]:\n        \"\"\"Process a list of items.\"\"\"\n        return [self.transformer(item) for item in items]\n\n    def process_parallel(self, items: List[T], max_workers: int = 4) -&gt; List[T]:\n        \"\"\"Process items in parallel.\"\"\"\n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            futures = [executor.submit(self.transformer, item) for item in items]\n            return [future.result() for future in as_completed(futures)]\n\nclass Pipeline(Generic[P, I, C]):\n    \"\"\"Type-safe pipeline with generics.\"\"\"\n\n    def __init__(self,\n                 poi_extractor: 'POIExtractor[P]',\n                 isochrone_generator: 'IsochroneGenerator[P, I]',\n                 census_integrator: 'CensusIntegrator[I, C]'):\n        self.poi_extractor = poi_extractor\n        self.isochrone_generator = isochrone_generator\n        self.census_integrator = census_integrator\n\n    def run(self) -&gt; 'PipelineResult[P, I, C]':\n        \"\"\"Run the pipeline with type safety.\"\"\"\n        # Extract POIs\n        pois: List[P] = self.poi_extractor.extract()\n\n        # Generate isochrones\n        isochrones: List[I] = self.isochrone_generator.generate(pois)\n\n        # Integrate census data\n        census_data: List[C] = self.census_integrator.integrate(isochrones)\n\n        return PipelineResult(\n            pois=pois,\n            isochrones=isochrones,\n            census_data=census_data\n        )\n\n@dataclass\nclass PipelineResult(Generic[P, I, C]):\n    \"\"\"Type-safe pipeline result.\"\"\"\n    pois: List[P]\n    isochrones: List[I]\n    census_data: List[C]\n\n    def filter_pois(self, predicate: Callable[[P], bool]) -&gt; List[P]:\n        \"\"\"Filter POIs with type safety.\"\"\"\n        return [poi for poi in self.pois if predicate(poi)]\n\n    def get_census_by_geography(self, geography_id: str) -&gt; Optional[C]:\n        \"\"\"Get census data by geography ID.\"\"\"\n        for data in self.census_data:\n            if data.geographic_id == geography_id:\n                return data\n        return None\n\n# Concrete implementations\nclass OSMPOIExtractor(Generic[P]):\n    \"\"\"OpenStreetMap POI extractor.\"\"\"\n\n    def __init__(self, config: OSMConfig, poi_factory: Callable[..., P]):\n        self.config = config\n        self.poi_factory = poi_factory\n\n    def extract(self) -&gt; List[P]:\n        \"\"\"Extract POIs from OSM.\"\"\"\n        # Implementation...\n        return []\n\n# Type-safe usage\ndef create_pipeline() -&gt; Pipeline[CustomPOI, CustomIsochrone, CustomCensusData]:\n    \"\"\"Create a type-safe pipeline.\"\"\"\n    return Pipeline(\n        poi_extractor=OSMPOIExtractor(osm_config, CustomPOI.from_osm),\n        isochrone_generator=CustomIsochroneGenerator(),\n        census_integrator=CustomCensusIntegrator()\n    )\n\n# Usage with type checking\npipeline = create_pipeline()\nresult = pipeline.run()\n\n# Type checker knows these types\nfor poi in result.pois:  # poi: CustomPOI\n    print(poi.custom_attribute)  # Type-safe access\n\nfor isochrone in result.isochrones:  # isochrone: CustomIsochrone\n    area = isochrone.calculate_custom_area()  # Type-safe method\n</code></pre>"},{"location":"API_MODERNIZATION_RECOMMENDATIONS/#26-dependency-injection","title":"2.6 Dependency Injection","text":"<pre><code>from typing import Protocol, Optional\nfrom dataclasses import dataclass\nimport inject\n\n# Define service protocols\nclass HTTPClientProtocol(Protocol):\n    \"\"\"Protocol for HTTP clients.\"\"\"\n    def get(self, url: str, **kwargs) -&gt; Any: ...\n    def post(self, url: str, **kwargs) -&gt; Any: ...\n\nclass CacheProtocol(Protocol):\n    \"\"\"Protocol for caching.\"\"\"\n    def get(self, key: str) -&gt; Optional[Any]: ...\n    def set(self, key: str, value: Any, ttl: Optional[int] = None) -&gt; None: ...\n\nclass LoggerProtocol(Protocol):\n    \"\"\"Protocol for logging.\"\"\"\n    def info(self, message: str) -&gt; None: ...\n    def error(self, message: str, exc_info: bool = False) -&gt; None: ...\n\n# Service implementations\n@dataclass\nclass ServiceContainer:\n    \"\"\"Dependency injection container.\"\"\"\n    http_client: HTTPClientProtocol\n    cache: CacheProtocol\n    logger: LoggerProtocol\n    config: SocialMapperConfig\n\n# Configure injection\ndef configure_injection(config: SocialMapperConfig):\n    \"\"\"Configure dependency injection.\"\"\"\n    def config_func(binder: inject.Binder):\n        # Bind interfaces to implementations\n        binder.bind(HTTPClientProtocol, RateLimitedClient(service=\"socialmapper\"))\n        binder.bind(CacheProtocol, RedisCache() if config.use_redis else InMemoryCache())\n        binder.bind(LoggerProtocol, StructuredLogger())\n        binder.bind(SocialMapperConfig, config)\n\n        # Bind service container\n        binder.bind_to_constructor(ServiceContainer, lambda: ServiceContainer(\n            http_client=inject.instance(HTTPClientProtocol),\n            cache=inject.instance(CacheProtocol),\n            logger=inject.instance(LoggerProtocol),\n            config=inject.instance(SocialMapperConfig)\n        ))\n\n    inject.configure(config_func)\n\n# Services using dependency injection\nclass POIExtractorService:\n    \"\"\"POI extraction service with injected dependencies.\"\"\"\n\n    @inject.params(container=ServiceContainer)\n    def __init__(self, container: ServiceContainer):\n        self.http_client = container.http_client\n        self.cache = container.cache\n        self.logger = container.logger\n        self.config = container.config\n\n    def extract_pois(self) -&gt; Result[List[POI], ProcessingError]:\n        \"\"\"Extract POIs using injected services.\"\"\"\n        # Check cache first\n        cache_key = self._generate_cache_key()\n        cached_pois = self.cache.get(cache_key)\n\n        if cached_pois:\n            self.logger.info(\"Using cached POIs\")\n            return Ok(cached_pois)\n\n        try:\n            # Extract from source\n            self.logger.info(\"Extracting POIs from source\")\n            response = self.http_client.get(self._build_query_url())\n            pois = self._parse_response(response)\n\n            # Cache results\n            self.cache.set(cache_key, pois, ttl=3600)\n\n            return Ok(pois)\n\n        except Exception as e:\n            self.logger.error(f\"POI extraction failed: {e}\", exc_info=True)\n            return Err(ProcessingError(\n                message=str(e),\n                code=\"POI_EXTRACTION_FAILED\",\n                stage=\"extraction\"\n            ))\n\nclass IsochroneGeneratorService:\n    \"\"\"Isochrone generation with dependency injection.\"\"\"\n\n    @inject.params(\n        http_client=HTTPClientProtocol,\n        cache=CacheProtocol,\n        logger=LoggerProtocol\n    )\n    def __init__(self, \n                 http_client: HTTPClientProtocol,\n                 cache: CacheProtocol,\n                 logger: LoggerProtocol):\n        self.http_client = http_client\n        self.cache = cache\n        self.logger = logger\n\n    async def generate_isochrone(self, poi: POI) -&gt; Result[Isochrone, ProcessingError]:\n        \"\"\"Generate isochrone for a POI.\"\"\"\n        # Implementation with injected dependencies\n        pass\n\n# Factory pattern with DI\nclass ServiceFactory:\n    \"\"\"Factory for creating services with dependency injection.\"\"\"\n\n    @staticmethod\n    @inject.params(container=ServiceContainer)\n    def create_poi_extractor(container: ServiceContainer) -&gt; POIExtractorService:\n        \"\"\"Create POI extractor with dependencies.\"\"\"\n        return POIExtractorService()\n\n    @staticmethod\n    @inject.params(container=ServiceContainer)\n    def create_pipeline(container: ServiceContainer) -&gt; Pipeline:\n        \"\"\"Create complete pipeline with dependencies.\"\"\"\n        return Pipeline(\n            poi_extractor=ServiceFactory.create_poi_extractor(),\n            isochrone_generator=IsochroneGeneratorService(),\n            census_integrator=CensusIntegratorService()\n        )\n\n# Usage\nconfig = SocialMapperConfig(...)\nconfigure_injection(config)\n\n# Services are automatically injected\npoi_service = POIExtractorService()  # Dependencies injected\nresult = poi_service.extract_pois()\n</code></pre>"},{"location":"API_MODERNIZATION_RECOMMENDATIONS/#27-api-versioning-strategy","title":"2.7 API Versioning Strategy","text":"<pre><code>from typing import Union\nfrom fastapi import FastAPI, APIRouter, Header, HTTPException\nfrom pydantic import BaseModel\nimport semver\n\n# Version-specific request/response models\nclass POIRequestV1(BaseModel):\n    \"\"\"V1 POI request model.\"\"\"\n    area: str\n    poi_type: str\n    poi_name: str\n\nclass POIRequestV2(BaseModel):\n    \"\"\"V2 POI request model with additional fields.\"\"\"\n    area: str\n    poi_type: str\n    poi_name: str\n    tags: Dict[str, str] = {}\n    max_results: int = 100\n\n# API versioning with headers\napp = FastAPI(title=\"SocialMapper API\")\n\n# Version routers\nv1_router = APIRouter(prefix=\"/api/v1\")\nv2_router = APIRouter(prefix=\"/api/v2\")\n\n@v1_router.post(\"/extract-pois\")\nasync def extract_pois_v1(request: POIRequestV1):\n    \"\"\"V1 API endpoint.\"\"\"\n    # V1 implementation\n    return {\"version\": \"1.0\", \"pois\": []}\n\n@v2_router.post(\"/extract-pois\")\nasync def extract_pois_v2(request: POIRequestV2):\n    \"\"\"V2 API endpoint with enhanced features.\"\"\"\n    # V2 implementation with tags and max_results\n    return {\"version\": \"2.0\", \"pois\": [], \"total\": 0}\n\n# Header-based versioning\n@app.post(\"/api/extract-pois\")\nasync def extract_pois(\n    request: Union[POIRequestV1, POIRequestV2],\n    api_version: str = Header(default=\"1.0\", alias=\"X-API-Version\")\n):\n    \"\"\"Version-aware endpoint.\"\"\"\n    version = semver.VersionInfo.parse(api_version)\n\n    if version.major == 1:\n        return await extract_pois_v1(POIRequestV1(**request.dict()))\n    elif version.major == 2:\n        return await extract_pois_v2(POIRequestV2(**request.dict()))\n    else:\n        raise HTTPException(\n            status_code=400,\n            detail=f\"Unsupported API version: {api_version}\"\n        )\n\n# SDK versioning\nclass SocialMapperSDK:\n    \"\"\"Versioned SDK for SocialMapper.\"\"\"\n\n    VERSION = \"2.0.0\"\n    SUPPORTED_API_VERSIONS = [\"1.0\", \"1.1\", \"2.0\"]\n\n    def __init__(self, api_version: Optional[str] = None):\n        self.api_version = api_version or self.VERSION\n        self._validate_version()\n\n    def _validate_version(self):\n        \"\"\"Validate API version compatibility.\"\"\"\n        if self.api_version not in self.SUPPORTED_API_VERSIONS:\n            raise ValueError(\n                f\"API version {self.api_version} not supported. \"\n                f\"Supported versions: {self.SUPPORTED_API_VERSIONS}\"\n            )\n\n    @property\n    def poi_extractor(self) -&gt; 'POIExtractor':\n        \"\"\"Get version-appropriate POI extractor.\"\"\"\n        version = semver.VersionInfo.parse(self.api_version)\n\n        if version.major == 1:\n            return POIExtractorV1()\n        else:\n            return POIExtractorV2()\n\n# Deprecation warnings\nimport warnings\nfrom functools import wraps\n\ndef deprecated(version: str, alternative: str):\n    \"\"\"Decorator for marking deprecated functions.\"\"\"\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            warnings.warn(\n                f\"{func.__name__} is deprecated as of version {version}. \"\n                f\"Use {alternative} instead.\",\n                DeprecationWarning,\n                stacklevel=2\n            )\n            return func(*args, **kwargs)\n        return wrapper\n    return decorator\n\n@deprecated(version=\"2.0.0\", alternative=\"SocialMapperBuilder\")\ndef create_socialmapper_config(**kwargs):\n    \"\"\"Legacy configuration function.\"\"\"\n    return SocialMapperConfig(**kwargs)\n</code></pre>"},{"location":"API_MODERNIZATION_RECOMMENDATIONS/#3-best-practices-evaluation","title":"3. Best Practices Evaluation","text":""},{"location":"API_MODERNIZATION_RECOMMENDATIONS/#31-restgraphql-style-api-design","title":"3.1 REST/GraphQL-style API Design","text":"<pre><code># REST API with FastAPI\nfrom fastapi import FastAPI, Query, Path, Body\nfrom typing import List, Optional\n\napp = FastAPI(\n    title=\"SocialMapper API\",\n    version=\"2.0.0\",\n    description=\"Community mapping and analysis API\"\n)\n\n# RESTful endpoints\n@app.post(\"/api/v2/analyses\", response_model=AnalysisResponse)\nasync def create_analysis(request: CreateAnalysisRequest):\n    \"\"\"Create a new analysis job.\"\"\"\n    job_id = await analysis_service.create_job(request)\n    return AnalysisResponse(\n        job_id=job_id,\n        status=\"pending\",\n        created_at=datetime.utcnow()\n    )\n\n@app.get(\"/api/v2/analyses/{job_id}\", response_model=AnalysisResponse)\nasync def get_analysis(job_id: str = Path(..., description=\"Analysis job ID\")):\n    \"\"\"Get analysis status and results.\"\"\"\n    return await analysis_service.get_job(job_id)\n\n@app.get(\"/api/v2/pois\", response_model=List[POIResponse])\nasync def list_pois(\n    area: str = Query(..., description=\"Geographic area\"),\n    poi_type: str = Query(..., description=\"POI type\"),\n    limit: int = Query(100, le=1000, description=\"Maximum results\"),\n    offset: int = Query(0, ge=0, description=\"Result offset\")\n):\n    \"\"\"List POIs with pagination.\"\"\"\n    return await poi_service.list_pois(area, poi_type, limit, offset)\n\n# GraphQL with Strawberry\nimport strawberry\nfrom strawberry.fastapi import GraphQLRouter\n\n@strawberry.type\nclass POI:\n    id: str\n    name: str\n    latitude: float\n    longitude: float\n    type: str\n    tags: Dict[str, str]\n\n@strawberry.type\nclass Isochrone:\n    id: str\n    poi: POI\n    travel_time: int\n    area_sq_km: float\n    population_covered: int\n\n@strawberry.type\nclass Query:\n    @strawberry.field\n    async def pois(\n        self,\n        area: str,\n        poi_type: str,\n        limit: int = 100\n    ) -&gt; List[POI]:\n        \"\"\"Query POIs.\"\"\"\n        return await poi_service.query_pois(area, poi_type, limit)\n\n    @strawberry.field\n    async def isochrone(self, poi_id: str, travel_time: int) -&gt; Isochrone:\n        \"\"\"Get isochrone for a POI.\"\"\"\n        return await isochrone_service.get_isochrone(poi_id, travel_time)\n\n@strawberry.type\nclass Mutation:\n    @strawberry.mutation\n    async def create_analysis(\n        self,\n        area: str,\n        poi_types: List[str],\n        travel_time: int,\n        census_variables: List[str]\n    ) -&gt; AnalysisJob:\n        \"\"\"Create a new analysis.\"\"\"\n        return await analysis_service.create_analysis(\n            area, poi_types, travel_time, census_variables\n        )\n\nschema = strawberry.Schema(query=Query, mutation=Mutation)\ngraphql_app = GraphQLRouter(schema)\napp.include_router(graphql_app, prefix=\"/graphql\")\n</code></pre>"},{"location":"API_MODERNIZATION_RECOMMENDATIONS/#32-input-validation-and-sanitization","title":"3.2 Input Validation and Sanitization","text":"<pre><code>from pydantic import BaseModel, Field, validator, root_validator\nfrom typing import List, Dict, Optional, Literal\nimport re\n\nclass CoordinateValidator:\n    \"\"\"Reusable coordinate validation.\"\"\"\n\n    @staticmethod\n    def validate_latitude(lat: float) -&gt; float:\n        if not -90 &lt;= lat &lt;= 90:\n            raise ValueError(\"Latitude must be between -90 and 90\")\n        return lat\n\n    @staticmethod\n    def validate_longitude(lon: float) -&gt; float:\n        if not -180 &lt;= lon &lt;= 180:\n            raise ValueError(\"Longitude must be between -180 and 180\")\n        return lon\n\nclass POICreateRequest(BaseModel):\n    \"\"\"Validated POI creation request.\"\"\"\n\n    name: str = Field(\n        ...,\n        min_length=1,\n        max_length=255,\n        description=\"POI name\"\n    )\n\n    latitude: float = Field(\n        ...,\n        ge=-90,\n        le=90,\n        description=\"Latitude in decimal degrees\"\n    )\n\n    longitude: float = Field(\n        ...,\n        ge=-180,\n        le=180,\n        description=\"Longitude in decimal degrees\"\n    )\n\n    poi_type: Literal[\"amenity\", \"leisure\", \"shop\", \"tourism\"] = Field(\n        ...,\n        description=\"POI type category\"\n    )\n\n    tags: Dict[str, str] = Field(\n        default_factory=dict,\n        description=\"Additional tags\"\n    )\n\n    @validator('name')\n    def sanitize_name(cls, v: str) -&gt; str:\n        \"\"\"Sanitize POI name.\"\"\"\n        # Remove dangerous characters\n        v = re.sub(r'[&lt;&gt;\\\"\\';&amp;]', '', v)\n        # Normalize whitespace\n        v = ' '.join(v.split())\n        return v.strip()\n\n    @validator('tags')\n    def validate_tags(cls, v: Dict[str, str]) -&gt; Dict[str, str]:\n        \"\"\"Validate and sanitize tags.\"\"\"\n        # Limit number of tags\n        if len(v) &gt; 20:\n            raise ValueError(\"Maximum 20 tags allowed\")\n\n        # Sanitize tag keys and values\n        sanitized = {}\n        for key, value in v.items():\n            # Validate key format\n            if not re.match(r'^[a-zA-Z][a-zA-Z0-9_]{0,49}$', key):\n                raise ValueError(f\"Invalid tag key: {key}\")\n\n            # Sanitize value\n            sanitized[key] = re.sub(r'[&lt;&gt;\\\"\\';&amp;]', '', str(value))[:255]\n\n        return sanitized\n\nclass AnalysisConfigRequest(BaseModel):\n    \"\"\"Validated analysis configuration.\"\"\"\n\n    area: str = Field(\n        ...,\n        min_length=2,\n        max_length=100,\n        description=\"Geographic area name\"\n    )\n\n    state: str = Field(\n        ...,\n        regex=r'^[A-Z]{2}$',\n        description=\"Two-letter state code\"\n    )\n\n    poi_types: List[str] = Field(\n        ...,\n        min_items=1,\n        max_items=10,\n        description=\"POI types to analyze\"\n    )\n\n    travel_time: int = Field(\n        15,\n        ge=1,\n        le=120,\n        description=\"Travel time in minutes\"\n    )\n\n    census_variables: List[str] = Field(\n        default_factory=lambda: [\"total_population\"],\n        max_items=50,\n        description=\"Census variables to retrieve\"\n    )\n\n    output_formats: List[Literal[\"csv\", \"json\", \"parquet\"]] = Field(\n        [\"csv\"],\n        description=\"Output formats\"\n    )\n\n    @validator('area')\n    def sanitize_area(cls, v: str) -&gt; str:\n        \"\"\"Sanitize area name.\"\"\"\n        # Remove special characters except spaces, hyphens, and apostrophes\n        v = re.sub(r'[^a-zA-Z0-9\\s\\-\\']', '', v)\n        return v.strip()\n\n    @validator('census_variables', each_item=True)\n    def validate_census_variable(cls, v: str) -&gt; str:\n        \"\"\"Validate census variable format.\"\"\"\n        # Check if it's a known friendly name or valid code\n        if v in CENSUS_VARIABLE_MAPPING:\n            return CENSUS_VARIABLE_MAPPING[v]\n\n        # Validate census code format (e.g., B01003_001E)\n        if not re.match(r'^[A-Z]\\d{5}_\\d{3}[A-Z]$', v):\n            raise ValueError(f\"Invalid census variable: {v}\")\n\n        return v\n\n    @root_validator\n    def validate_configuration(cls, values):\n        \"\"\"Cross-field validation.\"\"\"\n        # Ensure travel time is reasonable for the area\n        area = values.get('area', '')\n        travel_time = values.get('travel_time', 15)\n\n        # Large areas might need longer travel times\n        if 'county' in area.lower() and travel_time &lt; 30:\n            values['travel_time'] = 30\n\n        return values\n\n# File upload validation\nclass FileUploadValidator:\n    \"\"\"Validate uploaded files.\"\"\"\n\n    MAX_FILE_SIZE = 50 * 1024 * 1024  # 50MB\n    ALLOWED_EXTENSIONS = {'.csv', '.json', '.geojson', '.xlsx'}\n\n    @classmethod\n    def validate_file(cls, file: UploadFile) -&gt; Result[None, ValidationError]:\n        \"\"\"Validate uploaded file.\"\"\"\n        # Check file extension\n        ext = Path(file.filename).suffix.lower()\n        if ext not in cls.ALLOWED_EXTENSIONS:\n            return Err(ValidationError(\n                message=f\"File type {ext} not allowed\",\n                code=\"INVALID_FILE_TYPE\",\n                field=\"file\",\n                constraint=f\"allowed_types:{cls.ALLOWED_EXTENSIONS}\"\n            ))\n\n        # Check file size\n        if file.size &gt; cls.MAX_FILE_SIZE:\n            return Err(ValidationError(\n                message=f\"File too large: {file.size} bytes\",\n                code=\"FILE_TOO_LARGE\",\n                field=\"file\",\n                constraint=f\"max_size:{cls.MAX_FILE_SIZE}\"\n            ))\n\n        # Validate content based on type\n        if ext == '.csv':\n            return cls._validate_csv_content(file)\n        elif ext in {'.json', '.geojson'}:\n            return cls._validate_json_content(file)\n\n        return Ok(None)\n</code></pre>"},{"location":"API_MODERNIZATION_RECOMMENDATIONS/#33-rate-limiting-and-throttling","title":"3.3 Rate Limiting and Throttling","text":"<pre><code>from fastapi import FastAPI, Request, HTTPException\nfrom slowapi import Limiter, _rate_limit_exceeded_handler\nfrom slowapi.util import get_remote_address\nfrom slowapi.errors import RateLimitExceeded\nimport redis\nfrom datetime import datetime, timedelta\n\n# Configure rate limiter with Redis backend\nlimiter = Limiter(\n    key_func=get_remote_address,\n    storage_uri=\"redis://localhost:6379\"\n)\n\napp = FastAPI()\napp.state.limiter = limiter\napp.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)\n\n# Different rate limits for different endpoints\n@app.get(\"/api/v2/pois\")\n@limiter.limit(\"100/hour\")\nasync def list_pois(request: Request):\n    \"\"\"List POIs with rate limiting.\"\"\"\n    return {\"pois\": []}\n\n@app.post(\"/api/v2/analyses\")\n@limiter.limit(\"10/hour\")\nasync def create_analysis(request: Request):\n    \"\"\"Create analysis with stricter rate limit.\"\"\"\n    return {\"job_id\": \"...\"}\n\n# Custom rate limiting with user tiers\nclass TieredRateLimiter:\n    \"\"\"Rate limiter with user tiers.\"\"\"\n\n    TIERS = {\n        \"free\": {\"requests_per_hour\": 100, \"burst\": 10},\n        \"basic\": {\"requests_per_hour\": 1000, \"burst\": 50},\n        \"premium\": {\"requests_per_hour\": 10000, \"burst\": 200},\n        \"enterprise\": {\"requests_per_hour\": 100000, \"burst\": 1000}\n    }\n\n    def __init__(self, redis_client: redis.Redis):\n        self.redis = redis_client\n\n    async def check_rate_limit(self, user_id: str, tier: str) -&gt; bool:\n        \"\"\"Check if user is within rate limits.\"\"\"\n        limits = self.TIERS.get(tier, self.TIERS[\"free\"])\n\n        # Use sliding window algorithm\n        now = datetime.utcnow()\n        window_start = now - timedelta(hours=1)\n\n        # Count requests in the last hour\n        key = f\"rate_limit:{user_id}\"\n        pipe = self.redis.pipeline()\n\n        # Remove old entries\n        pipe.zremrangebyscore(key, 0, window_start.timestamp())\n\n        # Count current entries\n        pipe.zcard(key)\n\n        # Add current request\n        pipe.zadd(key, {str(now.timestamp()): now.timestamp()})\n\n        # Set expiry\n        pipe.expire(key, 3600)\n\n        results = pipe.execute()\n        request_count = results[1]\n\n        # Check burst limit\n        burst_key = f\"burst:{user_id}\"\n        burst_count = self.redis.incr(burst_key)\n        if burst_count == 1:\n            self.redis.expire(burst_key, 60)  # 1 minute window\n\n        if burst_count &gt; limits[\"burst\"]:\n            raise HTTPException(\n                status_code=429,\n                detail=\"Burst limit exceeded\",\n                headers={\"Retry-After\": \"60\"}\n            )\n\n        if request_count &gt;= limits[\"requests_per_hour\"]:\n            raise HTTPException(\n                status_code=429,\n                detail=\"Rate limit exceeded\",\n                headers={\"Retry-After\": \"3600\"}\n            )\n\n        return True\n\n# Middleware for API key validation and rate limiting\n@app.middleware(\"http\")\nasync def api_key_and_rate_limit_middleware(request: Request, call_next):\n    \"\"\"Validate API key and apply rate limits.\"\"\"\n    # Skip for health checks\n    if request.url.path == \"/health\":\n        return await call_next(request)\n\n    # Extract API key\n    api_key = request.headers.get(\"X-API-Key\")\n    if not api_key:\n        return JSONResponse(\n            status_code=401,\n            content={\"error\": \"API key required\"}\n        )\n\n    # Validate API key and get user info\n    user_info = await validate_api_key(api_key)\n    if not user_info:\n        return JSONResponse(\n            status_code=401,\n            content={\"error\": \"Invalid API key\"}\n        )\n\n    # Apply rate limiting based on tier\n    rate_limiter = TieredRateLimiter(redis_client)\n    await rate_limiter.check_rate_limit(\n        user_info[\"user_id\"],\n        user_info[\"tier\"]\n    )\n\n    # Add user info to request state\n    request.state.user_info = user_info\n\n    # Continue processing\n    response = await call_next(request)\n\n    # Add rate limit headers\n    response.headers[\"X-RateLimit-Limit\"] = str(\n        rate_limiter.TIERS[user_info[\"tier\"]][\"requests_per_hour\"]\n    )\n    response.headers[\"X-RateLimit-Remaining\"] = \"...\"  # Calculate remaining\n    response.headers[\"X-RateLimit-Reset\"] = \"...\"  # Next reset time\n\n    return response\n</code></pre>"},{"location":"API_MODERNIZATION_RECOMMENDATIONS/#34-caching-strategies","title":"3.4 Caching Strategies","text":"<pre><code>from functools import lru_cache, wraps\nfrom typing import Optional, Any, Callable\nimport hashlib\nimport pickle\nfrom datetime import datetime, timedelta\n\nclass CacheStrategy:\n    \"\"\"Base cache strategy.\"\"\"\n\n    def get_key(self, func: Callable, args: tuple, kwargs: dict) -&gt; str:\n        \"\"\"Generate cache key.\"\"\"\n        # Create unique key from function and arguments\n        key_parts = [\n            func.__module__,\n            func.__name__,\n            str(args),\n            str(sorted(kwargs.items()))\n        ]\n        key_string = \":\".join(key_parts)\n        return hashlib.sha256(key_string.encode()).hexdigest()\n\n    def should_cache(self, result: Any) -&gt; bool:\n        \"\"\"Determine if result should be cached.\"\"\"\n        return True\n\n    def get_ttl(self, result: Any) -&gt; Optional[int]:\n        \"\"\"Get TTL for cached result.\"\"\"\n        return 3600  # 1 hour default\n\nclass MultiLevelCache:\n    \"\"\"Multi-level caching system.\"\"\"\n\n    def __init__(self):\n        self.memory_cache = {}  # L1: In-memory\n        self.redis_client = redis.Redis()  # L2: Redis\n        self.s3_client = boto3.client('s3')  # L3: S3 for large objects\n\n    async def get(self, key: str) -&gt; Optional[Any]:\n        \"\"\"Get from cache, checking all levels.\"\"\"\n        # Check L1 (memory)\n        if key in self.memory_cache:\n            return self.memory_cache[key][\"value\"]\n\n        # Check L2 (Redis)\n        redis_value = self.redis_client.get(key)\n        if redis_value:\n            value = pickle.loads(redis_value)\n            # Promote to L1\n            self.memory_cache[key] = {\n                \"value\": value,\n                \"expires\": datetime.utcnow() + timedelta(minutes=5)\n            }\n            return value\n\n        # Check L3 (S3)\n        try:\n            response = self.s3_client.get_object(\n                Bucket=\"socialmapper-cache\",\n                Key=f\"cache/{key}\"\n            )\n            value = pickle.loads(response['Body'].read())\n            # Promote to L2 and L1\n            self.redis_client.setex(key, 3600, pickle.dumps(value))\n            self.memory_cache[key] = {\n                \"value\": value,\n                \"expires\": datetime.utcnow() + timedelta(minutes=5)\n            }\n            return value\n        except:\n            return None\n\n    async def set(self, key: str, value: Any, ttl: int = 3600):\n        \"\"\"Set in cache at appropriate level.\"\"\"\n        serialized = pickle.dumps(value)\n        size = len(serialized)\n\n        # Small objects go to all levels\n        if size &lt; 1024 * 1024:  # 1MB\n            # L1: Memory\n            self.memory_cache[key] = {\n                \"value\": value,\n                \"expires\": datetime.utcnow() + timedelta(seconds=ttl)\n            }\n\n            # L2: Redis\n            self.redis_client.setex(key, ttl, serialized)\n\n        # Large objects go to S3\n        if size &gt; 100 * 1024:  # 100KB\n            self.s3_client.put_object(\n                Bucket=\"socialmapper-cache\",\n                Key=f\"cache/{key}\",\n                Body=serialized,\n                Metadata={\"ttl\": str(ttl)}\n            )\n\n# Decorator for caching\ndef cached(\n    strategy: CacheStrategy = CacheStrategy(),\n    cache: Optional[MultiLevelCache] = None\n):\n    \"\"\"Decorator for caching function results.\"\"\"\n    if cache is None:\n        cache = MultiLevelCache()\n\n    def decorator(func):\n        @wraps(func)\n        async def async_wrapper(*args, **kwargs):\n            # Generate cache key\n            key = strategy.get_key(func, args, kwargs)\n\n            # Check cache\n            cached_result = await cache.get(key)\n            if cached_result is not None:\n                return cached_result\n\n            # Execute function\n            result = await func(*args, **kwargs)\n\n            # Cache if appropriate\n            if strategy.should_cache(result):\n                ttl = strategy.get_ttl(result)\n                await cache.set(key, result, ttl)\n\n            return result\n\n        @wraps(func)\n        def sync_wrapper(*args, **kwargs):\n            # Synchronous version\n            key = strategy.get_key(func, args, kwargs)\n\n            # Simple in-memory cache for sync\n            if not hasattr(func, '_cache'):\n                func._cache = {}\n\n            if key in func._cache:\n                return func._cache[key]\n\n            result = func(*args, **kwargs)\n\n            if strategy.should_cache(result):\n                func._cache[key] = result\n\n            return result\n\n        # Return appropriate wrapper\n        if asyncio.iscoroutinefunction(func):\n            return async_wrapper\n        else:\n            return sync_wrapper\n\n    return decorator\n\n# Specialized caching strategies\nclass GeocodingCacheStrategy(CacheStrategy):\n    \"\"\"Caching strategy for geocoding results.\"\"\"\n\n    def get_ttl(self, result: Any) -&gt; Optional[int]:\n        \"\"\"Geocoding results can be cached for a long time.\"\"\"\n        return 30 * 24 * 3600  # 30 days\n\n    def get_key(self, func: Callable, args: tuple, kwargs: dict) -&gt; str:\n        \"\"\"Normalize address for consistent caching.\"\"\"\n        if args and isinstance(args[0], str):\n            # Normalize address\n            address = args[0].lower().strip()\n            address = ' '.join(address.split())\n            return hashlib.sha256(address.encode()).hexdigest()\n        return super().get_key(func, args, kwargs)\n\nclass IsochroneCacheStrategy(CacheStrategy):\n    \"\"\"Caching strategy for isochrones.\"\"\"\n\n    def should_cache(self, result: Any) -&gt; bool:\n        \"\"\"Only cache successful isochrones.\"\"\"\n        return result is not None and hasattr(result, 'geometry')\n\n    def get_ttl(self, result: Any) -&gt; Optional[int]:\n        \"\"\"Isochrones valid for 7 days.\"\"\"\n        return 7 * 24 * 3600\n\n# Usage\n@cached(strategy=GeocodingCacheStrategy())\nasync def geocode_address(address: str) -&gt; Optional[Coordinates]:\n    \"\"\"Geocode address with caching.\"\"\"\n    # Expensive geocoding operation\n    return await geocoding_service.geocode(address)\n\n@cached(strategy=IsochroneCacheStrategy())\nasync def generate_isochrone(poi: POI, travel_time: int) -&gt; Optional[Isochrone]:\n    \"\"\"Generate isochrone with caching.\"\"\"\n    # Expensive isochrone generation\n    return await isochrone_service.generate(poi, travel_time)\n</code></pre>"},{"location":"API_MODERNIZATION_RECOMMENDATIONS/#4-specific-improvements-implementation","title":"4. Specific Improvements Implementation","text":""},{"location":"API_MODERNIZATION_RECOMMENDATIONS/#41-simplified-function-signature","title":"4.1 Simplified Function Signature","text":"<pre><code># Instead of 22 parameters, use a single configuration object\nclass SocialMapper:\n    \"\"\"Modern SocialMapper API.\"\"\"\n\n    def __init__(self, config: Optional[SocialMapperConfig] = None):\n        \"\"\"Initialize with optional configuration.\"\"\"\n        self.config = config or SocialMapperConfig()\n\n    def run(self, \n            analysis: AnalysisRequest,\n            options: Optional[RunOptions] = None) -&gt; Result[AnalysisResult, SocialMapperError]:\n        \"\"\"\n        Run analysis with simplified interface.\n\n        Args:\n            analysis: Analysis request configuration\n            options: Optional runtime options\n\n        Returns:\n            Result containing analysis results or error\n        \"\"\"\n        options = options or RunOptions()\n\n        # Validate inputs\n        validation = self._validate_analysis(analysis)\n        if validation.is_err():\n            return validation\n\n        # Run pipeline\n        try:\n            result = self._run_pipeline(analysis, options)\n            return Ok(result)\n        except Exception as e:\n            return Err(ProcessingError(\n                message=str(e),\n                code=\"PIPELINE_ERROR\",\n                stage=\"execution\"\n            ))\n\n    @classmethod\n    def from_builder(cls, builder: SocialMapperBuilder) -&gt; 'SocialMapper':\n        \"\"\"Create from builder.\"\"\"\n        config = builder.build()\n        return cls(config)\n\n# Clean usage\nmapper = SocialMapper.from_builder(\n    SocialMapperBuilder()\n    .with_osm_pois(\"San Francisco\", \"CA\", \"amenity\", \"library\")\n    .with_census_variables(\"median_income\", \"population\")\n    .enable_map_export()\n)\n\nresult = mapper.run(\n    AnalysisRequest(\n        travel_time=20,\n        geographic_level=\"block-group\"\n    )\n)\n</code></pre>"},{"location":"API_MODERNIZATION_RECOMMENDATIONS/#42-async-support-implementation","title":"4.2 Async Support Implementation","text":"<pre><code>class AsyncSocialMapper:\n    \"\"\"Fully async SocialMapper implementation.\"\"\"\n\n    async def run(self, \n                  analysis: AnalysisRequest) -&gt; AsyncIterator[AnalysisEvent]:\n        \"\"\"\n        Run analysis with streaming results.\n\n        Yields:\n            AnalysisEvent objects as processing progresses\n        \"\"\"\n        # Start analysis\n        yield AnalysisEvent(\n            type=\"started\",\n            timestamp=datetime.utcnow(),\n            data={\"request\": analysis}\n        )\n\n        # Extract POIs\n        async with self._progress_context(\"Extracting POIs\") as progress:\n            pois = []\n            async for poi in self._extract_pois_async(analysis):\n                pois.append(poi)\n                progress.update(len(pois))\n\n                # Yield progress events\n                if len(pois) % 10 == 0:\n                    yield AnalysisEvent(\n                        type=\"progress\",\n                        timestamp=datetime.utcnow(),\n                        data={\"stage\": \"extraction\", \"count\": len(pois)}\n                    )\n\n        yield AnalysisEvent(\n            type=\"stage_complete\",\n            timestamp=datetime.utcnow(),\n            data={\"stage\": \"extraction\", \"poi_count\": len(pois)}\n        )\n\n        # Generate isochrones concurrently\n        async with self._progress_context(\"Generating isochrones\") as progress:\n            isochrones = []\n            async for isochrone in self._generate_isochrones_async(pois):\n                isochrones.append(isochrone)\n                progress.update(len(isochrones))\n\n                yield AnalysisEvent(\n                    type=\"isochrone_generated\",\n                    timestamp=datetime.utcnow(),\n                    data={\"poi\": isochrone.poi.name}\n                )\n\n        # Stream census data\n        async for census_batch in self._stream_census_data(isochrones):\n            yield AnalysisEvent(\n                type=\"census_data\",\n                timestamp=datetime.utcnow(),\n                data={\"batch_size\": len(census_batch)}\n            )\n\n        # Final result\n        yield AnalysisEvent(\n            type=\"completed\",\n            timestamp=datetime.utcnow(),\n            data={\n                \"poi_count\": len(pois),\n                \"isochrone_count\": len(isochrones)\n            }\n        )\n\n# Usage with async iteration\nasync def process_analysis():\n    mapper = AsyncSocialMapper(config)\n\n    async for event in mapper.run(analysis_request):\n        match event.type:\n            case \"started\":\n                print(\"Analysis started\")\n            case \"progress\":\n                print(f\"Progress: {event.data}\")\n            case \"completed\":\n                print(f\"Analysis completed: {event.data}\")\n            case _:\n                print(f\"Event: {event}\")\n</code></pre>"},{"location":"API_MODERNIZATION_RECOMMENDATIONS/#43-proper-sdk-structure","title":"4.3 Proper SDK Structure","text":"<pre><code># socialmapper/\n# \u251c\u2500\u2500 __init__.py\n# \u251c\u2500\u2500 client.py          # Main client interface\n# \u251c\u2500\u2500 models/            # Data models\n# \u2502   \u251c\u2500\u2500 __init__.py\n# \u2502   \u251c\u2500\u2500 poi.py\n# \u2502   \u251c\u2500\u2500 isochrone.py\n# \u2502   \u2514\u2500\u2500 census.py\n# \u251c\u2500\u2500 services/          # Service layer\n# \u2502   \u251c\u2500\u2500 __init__.py\n# \u2502   \u251c\u2500\u2500 extraction.py\n# \u2502   \u251c\u2500\u2500 analysis.py\n# \u2502   \u2514\u2500\u2500 visualization.py\n# \u251c\u2500\u2500 utils/             # Utilities\n# \u2502   \u251c\u2500\u2500 __init__.py\n# \u2502   \u251c\u2500\u2500 validation.py\n# \u2502   \u2514\u2500\u2500 caching.py\n# \u2514\u2500\u2500 exceptions.py      # Custom exceptions\n\n# socialmapper/client.py\nclass SocialMapperClient:\n    \"\"\"Main SDK client.\"\"\"\n\n    def __init__(self, \n                 api_key: Optional[str] = None,\n                 base_url: str = \"https://api.socialmapper.io\",\n                 timeout: float = 30.0,\n                 max_retries: int = 3):\n        \"\"\"\n        Initialize SocialMapper client.\n\n        Args:\n            api_key: API key for authentication\n            base_url: Base URL for API\n            timeout: Request timeout in seconds\n            max_retries: Maximum retry attempts\n        \"\"\"\n        self.api_key = api_key or os.getenv(\"SOCIALMAPPER_API_KEY\")\n        self.base_url = base_url\n        self.timeout = timeout\n        self.max_retries = max_retries\n\n        # Initialize HTTP client\n        self._client = httpx.Client(\n            base_url=base_url,\n            timeout=timeout,\n            headers={\"X-API-Key\": self.api_key} if self.api_key else {}\n        )\n\n        # Initialize services\n        self.pois = POIService(self._client)\n        self.isochrones = IsochroneService(self._client)\n        self.census = CensusService(self._client)\n        self.analysis = AnalysisService(self._client)\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self._client.close()\n\n    def create_analysis(self) -&gt; AnalysisBuilder:\n        \"\"\"Create a new analysis using builder pattern.\"\"\"\n        return AnalysisBuilder(self)\n\n# socialmapper/services/analysis.py\nclass AnalysisService:\n    \"\"\"Analysis service.\"\"\"\n\n    def __init__(self, client: httpx.Client):\n        self._client = client\n\n    def create(self, request: AnalysisRequest) -&gt; Result[AnalysisJob, APIError]:\n        \"\"\"Create a new analysis job.\"\"\"\n        try:\n            response = self._client.post(\"/analyses\", json=request.dict())\n            response.raise_for_status()\n            return Ok(AnalysisJob(**response.json()))\n        except httpx.HTTPStatusError as e:\n            return Err(APIError(\n                message=f\"Failed to create analysis: {e.response.text}\",\n                code=\"ANALYSIS_CREATE_FAILED\",\n                service=\"analysis\",\n                status_code=e.response.status_code\n            ))\n\n    def get_status(self, job_id: str) -&gt; Result[JobStatus, APIError]:\n        \"\"\"Get analysis job status.\"\"\"\n        try:\n            response = self._client.get(f\"/analyses/{job_id}\")\n            response.raise_for_status()\n            return Ok(JobStatus(**response.json()))\n        except httpx.HTTPStatusError as e:\n            return Err(APIError(\n                message=f\"Failed to get job status: {e.response.text}\",\n                code=\"JOB_STATUS_FAILED\",\n                service=\"analysis\",\n                status_code=e.response.status_code\n            ))\n\n    async def stream_results(self, job_id: str) -&gt; AsyncIterator[AnalysisResult]:\n        \"\"\"Stream analysis results as they become available.\"\"\"\n        async with self._client.stream(\"GET\", f\"/analyses/{job_id}/stream\") as response:\n            async for line in response.aiter_lines():\n                if line:\n                    data = json.loads(line)\n                    yield AnalysisResult(**data)\n\n# Usage\nfrom socialmapper import SocialMapperClient\n\n# Simple usage\nwith SocialMapperClient(api_key=\"your-api-key\") as client:\n    # Create analysis\n    analysis = (client.create_analysis()\n        .for_area(\"San Francisco\", \"CA\")\n        .with_pois(\"amenity\", \"library\")\n        .with_travel_time(20)\n        .with_census_variables(\"median_income\", \"population\")\n        .build()\n    )\n\n    # Submit analysis\n    result = client.analysis.create(analysis)\n\n    if result.is_ok():\n        job = result.unwrap()\n        print(f\"Analysis started: {job.id}\")\n\n        # Poll for results\n        while True:\n            status = client.analysis.get_status(job.id)\n            if status.is_ok() and status.unwrap().is_complete:\n                break\n            time.sleep(5)\n    else:\n        print(f\"Error: {result.unwrap_err()}\")\n\n# Async usage\nasync def run_analysis():\n    async with AsyncSocialMapperClient(api_key=\"your-api-key\") as client:\n        # Stream results\n        async for result in client.analysis.stream_results(job_id):\n            print(f\"Received: {result}\")\n</code></pre>"},{"location":"API_MODERNIZATION_RECOMMENDATIONS/#summary","title":"Summary","text":"<p>The modernization recommendations focus on:</p> <ol> <li>Simplifying the API through builder patterns and configuration objects</li> <li>Adding async support for better performance with I/O operations</li> <li>Implementing Result types for explicit error handling</li> <li>Using context managers for resource management</li> <li>Ensuring type safety with generics and protocols</li> <li>Supporting dependency injection for testability</li> <li>Implementing API versioning for backward compatibility</li> <li>Adding comprehensive validation and sanitization</li> <li>Including rate limiting and caching strategies</li> <li>Creating a proper SDK structure for ease of use</li> </ol> <p>These improvements would make SocialMapper's API more modern, maintainable, and user-friendly while following current best practices in API design.</p>"},{"location":"ARCHITECTURE/","title":"\ud83c\udfd7\ufe0f SocialMapper Architecture Guide","text":""},{"location":"ARCHITECTURE/#current-structure-analysis","title":"Current Structure Analysis","text":""},{"location":"ARCHITECTURE/#well-organized-components","title":"\u2705 Well-Organized Components","text":"<pre><code>socialmapper/\n\u251c\u2500\u2500 data/              # Data management (streaming, memory)\n\u251c\u2500\u2500 export/           # Data export and static maps\n\u251c\u2500\u2500 ui/               # User interfaces (CLI, Rich terminal)\n\u251c\u2500\u2500 config/           # Configuration management\n\u2514\u2500\u2500 progress/         # Progress tracking\n</code></pre>"},{"location":"ARCHITECTURE/#areas-for-improvement","title":"\u26a0\ufe0f Areas for Improvement","text":""},{"location":"ARCHITECTURE/#1-core-module-size","title":"1. Core Module Size","text":"<ul> <li><code>core.py</code> (769 lines) - Monolithic function that handles entire pipeline</li> <li>Recommendation: Break into smaller, composable functions</li> </ul>"},{"location":"ARCHITECTURE/#2-mixed-abstraction-levels","title":"2. Mixed Abstraction Levels","text":"<pre><code># Current: Mixed levels in root\nsocialmapper/\n\u251c\u2500\u2500 distance/         # Low-level processing\n\u251c\u2500\u2500 isochrone/        # Low-level processing  \n\u251c\u2500\u2500 export/           # High-level output\n\u251c\u2500\u2500 query/            # Low-level data acquisition\n\u2514\u2500\u2500 core.py           # High-level orchestration\n</code></pre>"},{"location":"ARCHITECTURE/#3-inconsistent-naming","title":"3. Inconsistent Naming","text":"<ul> <li>Some modules use singular (<code>distance/</code>) others plural (<code>counties/</code>)</li> <li>Mixed naming conventions across similar components</li> </ul>"},{"location":"ARCHITECTURE/#recommended-modern-structure","title":"\ud83c\udfaf Recommended Modern Structure","text":""},{"location":"ARCHITECTURE/#option-a-etl-based-organization","title":"Option A: ETL-Based Organization","text":"<pre><code>socialmapper/\n\u251c\u2500\u2500 pipeline/         # Core ETL pipeline\n\u2502   \u251c\u2500\u2500 extract/      # Data acquisition (POI, Census)\n\u2502   \u251c\u2500\u2500 transform/    # Processing (distance, isochrone)\n\u2502   \u2514\u2500\u2500 load/         # Output (export, static maps)\n\u251c\u2500\u2500 sources/          # External data adapters\n\u2502   \u251c\u2500\u2500 census/       # Census Bureau APIs\n\u2502   \u251c\u2500\u2500 osm/          # OpenStreetMap integration\n\u2502   \u2514\u2500\u2500 geography/    # Geographic boundaries\n\u251c\u2500\u2500 interfaces/       # User-facing components\n\u2502   \u251c\u2500\u2500 api/          # Python API (core.py)\n\u2502   \u251c\u2500\u2500 cli/          # Command-line interface\n\u2502   \u2514\u2500\u2500 terminal/     # Rich terminal interface\n\u2514\u2500\u2500 common/           # Shared utilities\n    \u251c\u2500\u2500 config/       # Configuration\n    \u251c\u2500\u2500 types/        # Type definitions\n    \u2514\u2500\u2500 utils/        # Helper functions\n</code></pre>"},{"location":"ARCHITECTURE/#option-b-domain-based-organization","title":"Option B: Domain-Based Organization","text":"<pre><code>socialmapper/\n\u251c\u2500\u2500 geospatial/       # All geographic operations\n\u2502   \u251c\u2500\u2500 distance/\n\u2502   \u251c\u2500\u2500 isochrone/\n\u2502   \u2514\u2500\u2500 boundaries/\n\u251c\u2500\u2500 data/             # Data management\n\u2502   \u251c\u2500\u2500 census/\n\u2502   \u251c\u2500\u2500 osm/\n\u2502   \u2514\u2500\u2500 streaming/\n\u251c\u2500\u2500 interfaces/       # User interfaces\n\u2514\u2500\u2500 core/             # Business logic\n</code></pre>"},{"location":"ARCHITECTURE/#implementation-strategy","title":"\ud83d\ude80 Implementation Strategy","text":""},{"location":"ARCHITECTURE/#phase-1-documentation-planning","title":"Phase 1: Documentation &amp; Planning","text":"<ul> <li> Document current architecture</li> <li> Identify improvement areas</li> <li> Create migration plan</li> <li> Set up backward compatibility</li> </ul>"},{"location":"ARCHITECTURE/#phase-2-internal-refactoring-no-breaking-changes","title":"Phase 2: Internal Refactoring (No Breaking Changes)","text":"<ul> <li> Break down <code>core.py</code> into smaller functions</li> <li> Improve internal module organization</li> <li> Add type hints and documentation</li> <li> Standardize naming conventions</li> </ul>"},{"location":"ARCHITECTURE/#phase-3-structural-improvements","title":"Phase 3: Structural Improvements","text":"<ul> <li> Implement new directory structure</li> <li> Update import paths</li> <li> Maintain backward compatibility aliases</li> <li> Update documentation</li> </ul>"},{"location":"ARCHITECTURE/#phase-4-cleanup","title":"Phase 4: Cleanup","text":"<ul> <li> Remove deprecated aliases</li> <li> Final testing and validation</li> <li> Update examples and documentation</li> </ul>"},{"location":"ARCHITECTURE/#benefits-of-refactoring","title":"\ud83d\udcca Benefits of Refactoring","text":""},{"location":"ARCHITECTURE/#developer-experience","title":"Developer Experience","text":"<ul> <li>Clearer Mental Model: ETL stages are intuitive</li> <li>Easier Navigation: Related code is co-located</li> <li>Better Testing: Smaller, focused modules</li> <li>Reduced Complexity: Single responsibility principle</li> </ul>"},{"location":"ARCHITECTURE/#maintainability","title":"Maintainability","text":"<ul> <li>Easier Debugging: Clear separation of concerns</li> <li>Simpler Onboarding: Logical structure for new contributors</li> <li>Better Documentation: Structure reflects functionality</li> <li>Future Extensions: Clear places for new features</li> </ul>"},{"location":"ARCHITECTURE/#performance","title":"Performance","text":"<ul> <li>Lazy Loading: Import only what's needed</li> <li>Better Caching: Clear data flow patterns</li> <li>Optimized Imports: Reduced circular dependencies</li> </ul>"},{"location":"ARCHITECTURE/#next-steps","title":"\ud83c\udfaf Next Steps","text":"<ol> <li>Immediate (No Breaking Changes):</li> <li>Refactor <code>core.py</code> into smaller functions</li> <li>Add comprehensive type hints</li> <li> <p>Improve documentation</p> </li> <li> <p>Short-term (Backward Compatible):</p> </li> <li>Create new structure alongside existing</li> <li>Add compatibility aliases</li> <li> <p>Gradual migration of internal imports</p> </li> <li> <p>Long-term (Major Version):</p> </li> <li>Complete structural reorganization</li> <li>Remove compatibility aliases</li> <li>Update all documentation and examples</li> </ol>"},{"location":"ARCHITECTURE/#implementation-guidelines","title":"\ud83d\udd27 Implementation Guidelines","text":""},{"location":"ARCHITECTURE/#naming-conventions","title":"Naming Conventions","text":"<ul> <li>Use singular for modules (<code>distance/</code>, not <code>distances/</code>)</li> <li>Use verbs for functions (<code>calculate_distance</code>, not <code>distance_calc</code>)</li> <li>Use nouns for classes (<code>DistanceCalculator</code>, not <code>CalculateDistance</code>)</li> </ul>"},{"location":"ARCHITECTURE/#import-patterns","title":"Import Patterns","text":"<pre><code># Preferred: Explicit imports\nfrom socialmapper.pipeline.extract import query_pois\nfrom socialmapper.pipeline.transform import calculate_distances\n\n# Avoid: Star imports\nfrom socialmapper.pipeline.extract import *\n</code></pre>"},{"location":"ARCHITECTURE/#backward-compatibility","title":"Backward Compatibility","text":"<pre><code># In __init__.py - maintain old imports\nfrom .pipeline.extract.query import query_pois as query_overpass  # Old name\nfrom .pipeline.transform.distance import calculate_distances\n</code></pre> <p>This architecture guide provides a roadmap for improving SocialMapper's structure while maintaining stability and usability. </p>"},{"location":"CHANGELOG/","title":"SocialMapper Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"CHANGELOG/#051-2025-06-07","title":"[0.5.1] - 2025-06-07","text":""},{"location":"CHANGELOG/#major-features","title":"\ud83d\ude80 Major Features","text":""},{"location":"CHANGELOG/#python-313-support","title":"\u2728 Python 3.13 Support","text":"<ul> <li>Full compatibility with Python 3.13.3 (latest)</li> <li>Updated dependencies including NumPy 2.2+, OSMnx 2.0.3, NumBa 0.61+</li> <li>Performance improvements from Python 3.13 optimizations</li> <li>Future-ready development environment</li> </ul>"},{"location":"CHANGELOG/#rich-terminal-ui-integration","title":"\ud83c\udfa8 Rich Terminal UI Integration","text":"<ul> <li>Beautiful progress bars with stage-based tracking and performance metrics</li> <li>Enhanced console output with banners, panels, and formatted tables</li> <li>Status spinners for long-running operations</li> <li>Rich tracebacks for better error debugging</li> <li>Color-coded messages for success, warnings, and errors</li> </ul>"},{"location":"CHANGELOG/#osmnx-20-compatibility","title":"\ud83d\uddfa\ufe0f OSMnx 2.0+ Compatibility","text":"<ul> <li>Faster network creation (~1 second for medium cities)</li> <li>Enhanced geometry handling for POIs, buildings, and parks</li> <li>Improved intersection consolidation for more accurate demographics</li> <li>Better error handling and type annotations</li> <li>Advanced routing capabilities with multiple algorithms</li> </ul>"},{"location":"CHANGELOG/#technical-improvements","title":"\ud83d\udd27 Technical Improvements","text":""},{"location":"CHANGELOG/#dependency-updates","title":"Dependency Updates","text":"<ul> <li><code>python&gt;=3.11,&lt;3.14</code> (added Python 3.13 support)</li> <li><code>numba&gt;=0.61.0</code> (Python 3.13 compatibility)</li> <li><code>osmnx&gt;=1.2.2</code> (leverages OSMnx 2.0+ features)</li> <li><code>rich&gt;=13.0.0</code> (beautiful terminal output)</li> </ul>"},{"location":"CHANGELOG/#architecture-fixes","title":"Architecture Fixes","text":"<ul> <li>Fixed circular imports between <code>core.py</code> and UI modules</li> <li>Streamlined module structure for better maintainability</li> <li>Enhanced error handling throughout the pipeline</li> <li>Improved type hints for better development experience</li> </ul>"},{"location":"CHANGELOG/#performance-enhancements","title":"Performance Enhancements","text":"<ul> <li>Faster POI discovery with OSMnx 2.0 optimizations</li> <li>Memory efficiency improvements for large datasets</li> <li>Better caching for network requests and data processing</li> <li>Optimized graph operations for community analysis</li> </ul>"},{"location":"CHANGELOG/#new-capabilities","title":"\ud83d\udcca New Capabilities","text":""},{"location":"CHANGELOG/#rich-progress-tracking","title":"Rich Progress Tracking","text":"<pre><code># New beautiful progress bars with metrics\n\ud83d\udd17 Optimizing POI clusters \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 25/25 100% 0:00:00\n\u2705 Completed: Processing points of interest (2.6s, 9.5 items/s)\n</code></pre>"},{"location":"CHANGELOG/#enhanced-console-output","title":"Enhanced Console Output","text":"<ul> <li>Formatted tables for census variables and POI summaries</li> <li>Performance summaries with throughput metrics</li> <li>File generation reports with status indicators</li> <li>Pipeline overviews with stage-by-stage timing</li> </ul>"},{"location":"CHANGELOG/#advanced-network-analysis","title":"Advanced Network Analysis","text":"<ul> <li>Multi-modal networks (walk, drive, bike)</li> <li>Centrality calculations (betweenness, closeness)</li> <li>Street orientation analysis for urban form studies</li> <li>Building footprint integration for detailed demographics</li> </ul>"},{"location":"CHANGELOG/#community-impact","title":"\ud83c\udfd8\ufe0f Community Impact","text":""},{"location":"CHANGELOG/#faster-analysis","title":"Faster Analysis","text":"<ul> <li>2-5x speed improvements for POI discovery</li> <li>Sub-second network creation for medium cities</li> <li>Efficient batch processing for multiple locations</li> <li>Real-time routing with &lt;2ms path calculations</li> </ul>"},{"location":"CHANGELOG/#enhanced-accuracy","title":"Enhanced Accuracy","text":"<ul> <li>Better intersection handling for precise demographics</li> <li>Improved geometric calculations with modern libraries</li> <li>More reliable data processing with enhanced error handling</li> <li>Building-level analysis capabilities with footprint data</li> </ul>"},{"location":"CHANGELOG/#performance-metrics","title":"\ud83d\udcc8 Performance Metrics","text":"Operation v0.5.0 v0.5.1 Improvement Network Creation ~3-5s ~1s 3-5x faster POI Discovery Variable &lt;1s Consistent speed Error Recovery Manual Automatic Better reliability Memory Usage High Optimized More efficient"},{"location":"CHANGELOG/#bug-fixes","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>Fixed circular import between core and UI modules</li> <li>Resolved Python 3.13 compatibility issues with scientific stack</li> <li>Improved error handling for malformed OpenStreetMap data</li> <li>Better memory management for large geographic datasets</li> <li>Enhanced exception reporting with Rich tracebacks</li> </ul>"},{"location":"CHANGELOG/#050-2025-06-01","title":"[0.5.0] - 2025-06-01","text":""},{"location":"CHANGELOG/#overview","title":"Overview","text":"<p>SocialMapper v0.5.0 is a minor release focused on significant performance optimizations of the core processing engine. While the underlying algorithms have been substantially improved, this release includes breaking changes to the Streamlit interface and should be considered a pre-release version.</p>"},{"location":"CHANGELOG/#key-changes","title":"\ud83d\ude80 Key Changes","text":"<ul> <li>17.3x Performance Improvement: Core processing engine optimized for large datasets</li> <li>Internal Architecture Updates: Modernized distance calculations and isochrone generation</li> <li>Memory Optimization: 84% reduction in memory usage through streaming</li> <li>Breaking Changes: Streamlit UI components require updates</li> <li>Pre-release Status: May contain bugs, not recommended for production use</li> </ul>"},{"location":"CHANGELOG/#important-notes","title":"\u26a0\ufe0f Important Notes","text":"<ul> <li>Streamlit App: The web interface has breaking changes and may not function correctly</li> <li>Pre-release Software: This version may contain bugs and is not production-ready</li> <li>API Changes: Some internal APIs have changed, though main functions remain compatible</li> <li>Testing Recommended: Thoroughly test with your specific use cases before deployment</li> </ul>"},{"location":"CHANGELOG/#performance-improvements","title":"\ud83d\udcca Performance Improvements","text":""},{"location":"CHANGELOG/#benchmark-results","title":"Benchmark Results","text":"Dataset Size v0.4.3 v0.5.0 Improvement Notes 50 POIs ~45 minutes 1.1 minutes 41x faster Core engine only 500 POIs ~4.5 hours 5.2 minutes 52x faster Core engine only 2,659 POIs 5.3 hours 18.5 minutes 17.3x faster Core engine only"},{"location":"CHANGELOG/#performance-metrics_1","title":"Performance Metrics","text":"<ul> <li>Per-POI Processing: Improved from 7.2s to 0.42s</li> <li>Memory Usage: 84% reduction through streaming architecture</li> <li>CPU Utilization: Better parallelization (45.7% usage)</li> <li>Scaling: Improved efficiency with larger datasets</li> </ul>"},{"location":"CHANGELOG/#technical-changes","title":"\ud83d\udd27 Technical Changes","text":""},{"location":"CHANGELOG/#1-distance-engine-optimization","title":"1. Distance Engine Optimization","text":"<p>Updated the core distance calculation system:</p> <pre><code># Updated engine (internal changes)\nfrom socialmapper.distance import VectorizedDistanceEngine\n\nengine = VectorizedDistanceEngine(n_jobs=-1)\ndistances = engine.calculate_distances(poi_points, centroids)\n# Significant performance improvement for large datasets\n</code></pre> <p>Changes: - Implemented Numba JIT compilation - Vectorized NumPy operations - Improved parallelization - Better memory management</p>"},{"location":"CHANGELOG/#2-isochrone-system-updates","title":"2. Isochrone System Updates","text":"<p>Enhanced spatial processing and caching:</p> <pre><code># Updated clustering (may have API changes)\nfrom socialmapper.isochrone import IntelligentPOIClusterer\n\nclusterer = IntelligentPOIClusterer(max_cluster_radius_km=15.0)\nclusters = clusterer.cluster_pois(pois, travel_time_minutes=15)\n# 80% reduction in network downloads, improved caching\n</code></pre> <p>Changes: - DBSCAN clustering implementation - SQLite-based caching system - Concurrent processing improvements - Network download optimization</p>"},{"location":"CHANGELOG/#3-data-pipeline-modernization","title":"3. Data Pipeline Modernization","text":"<p>Streaming architecture implementation:</p> <pre><code># New data pipeline (experimental)\nfrom socialmapper.data import StreamingDataPipeline\n\nwith StreamingDataPipeline() as pipeline:\n    # Memory-efficient processing\n    pipeline.process_data(data)\n# Significant memory reduction for large datasets\n</code></pre> <p>Changes: - Streaming data processing - Modern file formats (Parquet support) - Memory monitoring and optimization - Improved error handling</p>"},{"location":"CHANGELOG/#breaking-changes","title":"\ud83d\udea8 Breaking Changes","text":""},{"location":"CHANGELOG/#streamlit-interface","title":"Streamlit Interface","text":"<p>\u26a0\ufe0f The Streamlit web interface has breaking changes:</p> <ul> <li>Some UI components may not function correctly</li> <li>Configuration options may have changed</li> <li>Visualization features may be affected</li> <li>Requires updates to work with new backend</li> </ul>"},{"location":"CHANGELOG/#api-changes","title":"API Changes","text":"<p>While main functions remain compatible, some internal APIs have changed:</p> <ul> <li>Distance calculation internals updated</li> <li>Isochrone clustering parameters may differ</li> <li>Configuration system restructured</li> <li>Some utility functions relocated</li> </ul>"},{"location":"CHANGELOG/#migration-notes","title":"\ud83d\udd04 Migration Notes","text":""},{"location":"CHANGELOG/#core-api-compatibility","title":"Core API Compatibility","text":"<p>Most existing code should continue to work:</p> <pre><code># Main functions remain compatible\nimport socialmapper\n\nresult = socialmapper.run_socialmapper(\n    poi_data=poi_data,\n    travel_time_minutes=15,\n    output_dir=\"output\"\n)\n# Should work but test thoroughly\n</code></pre>"},{"location":"CHANGELOG/#known-issues","title":"Known Issues","text":"<ul> <li>Streamlit interface requires updates</li> <li>Some configuration options may have changed</li> <li>Error messages may be different</li> <li>Performance characteristics changed (mostly improved)</li> </ul>"},{"location":"CHANGELOG/#rollback-plan","title":"Rollback Plan","text":"<p>If issues occur, rollback to previous version:</p> <pre><code>pip install socialmapper==0.4.3\n</code></pre>"},{"location":"DEMO_INSTRUCTIONS/","title":"\ud83d\ude80 ZCTA Demo Quick Start Guide","text":"<p>This guide provides step-by-step instructions for testing the new ZCTA (ZIP Code Tabulation Area) feature in SocialMapper.</p>"},{"location":"DEMO_INSTRUCTIONS/#tldr-run-the-demo-now","title":"\u26a1 TL;DR - Run the Demo Now","text":"<pre><code># Full interactive demo (recommended)\npython demo_zcta_feature.py\n\n# Quick CLI tests\npython test_zcta_cli.py\n</code></pre>"},{"location":"DEMO_INSTRUCTIONS/#demo-options","title":"\ud83d\udccb Demo Options","text":""},{"location":"DEMO_INSTRUCTIONS/#option-1-full-interactive-demo-recommended","title":"Option 1: \ud83c\udfac Full Interactive Demo (Recommended)","text":"<p>What it does: Side-by-side comparison of block groups vs ZCTAs with real Seattle library data</p> <pre><code>python demo_zcta_feature.py\n</code></pre> <p>Expected runtime: 3-5 minutes Output:  - Rich interactive comparison tables - Sample data files created automatically - Complete analysis results in separate directories - CLI usage examples</p>"},{"location":"DEMO_INSTRUCTIONS/#option-2-quick-cli-tests","title":"Option 2: \ud83e\uddea Quick CLI Tests","text":"<p>What it does: Fast validation that ZCTA commands work properly</p> <pre><code>python test_zcta_cli.py\n</code></pre> <p>Expected runtime: 2-3 minutes Output: Pass/fail status for each CLI scenario</p>"},{"location":"DEMO_INSTRUCTIONS/#option-3-manual-cli-testing","title":"Option 3: \ud83d\udcbb Manual CLI Testing","text":"<p>Test individual commands manually:</p> <pre><code># Create test data first\nmkdir test_data\necho \"name,lat,lon,type\nLibrary 1,47.6062,-122.3321,library\nLibrary 2,47.6613,-122.3138,library\" &gt; test_data/coords.csv\n\n# Test block groups (baseline)\npython -m socialmapper.cli --custom-coords test_data/coords.csv \\\n  --travel-time 10 --geographic-level block-group\n\n# Test ZCTAs (new feature) \npython -m socialmapper.cli --custom-coords test_data/coords.csv \\\n  --travel-time 10 --geographic-level zcta\n</code></pre>"},{"location":"DEMO_INSTRUCTIONS/#what-to-look-for","title":"\ud83c\udfaf What to Look For","text":""},{"location":"DEMO_INSTRUCTIONS/#success-indicators","title":"\u2705 Success Indicators","text":"<ol> <li>Processing Messages: Look for \"Finding ZIP Code Tabulation Areas\" vs \"Finding Census Block Groups\"</li> <li>Unit Counts: ZCTAs should show fewer units (larger geographic areas)</li> <li>Processing Speed: ZCTAs may be faster due to fewer units</li> <li>Output Files: Same structure but different data granularity</li> </ol>"},{"location":"DEMO_INSTRUCTIONS/#expected-differences","title":"\ud83d\udcca Expected Differences","text":"Aspect Block Groups ZCTAs Geographic Units 50-200 units 5-20 units Processing Time Longer Shorter Data Granularity Fine-grained Broader patterns Use Case Neighborhood analysis ZIP code regions"},{"location":"DEMO_INSTRUCTIONS/#files-to-check","title":"\ud83d\udd0d Files to Check","text":"<p>After running demos, examine these files:</p> <pre><code>\ud83d\udcc1 demo_output_libraries/          # Block group results\n\u251c\u2500\u2500 *_census_data.csv             # Fine-grained data\n\u2514\u2500\u2500 maps/                         # Detailed maps\n\n\ud83d\udcc1 demo_output_libraries_zcta/     # ZCTA results  \n\u251c\u2500\u2500 *_census_data.csv             # ZIP code level data\n\u2514\u2500\u2500 maps/                         # Regional maps\n</code></pre>"},{"location":"DEMO_INSTRUCTIONS/#troubleshooting","title":"\ud83d\udc1b Troubleshooting","text":""},{"location":"DEMO_INSTRUCTIONS/#common-issues-solutions","title":"Common Issues &amp; Solutions","text":"<p>\"Command not found\" <pre><code># Ensure SocialMapper is installed\npip install -e .\n</code></pre></p> <p>\"No ZCTAs found\" - Use US coordinates only - Check lat/lon format (latitude, longitude) - Try larger travel times (15+ minutes)</p> <p>\"Slow performance\" <pre><code># Optional: Add Census API key for faster performance\nexport CENSUS_API_KEY=\"your_key_here\"\n</code></pre></p> <p>\"Import errors\" <pre><code># Install demo dependencies\npip install rich pandas geopandas\n</code></pre></p>"},{"location":"DEMO_INSTRUCTIONS/#quick-fixes","title":"\ud83d\udd27 Quick Fixes","text":"<p>Reset everything: <pre><code>rm -rf demo_zcta_data/ demo_output_* test_data/ output/\npython demo_zcta_feature.py\n</code></pre></p> <p>Test minimal case: <pre><code>python -m socialmapper.cli --poi --geocode-area \"Seattle\" --state \"WA\" \\\n  --poi-type \"amenity\" --poi-name \"library\" --geographic-level zcta \\\n  --travel-time 15 --export-csv --no-export-maps\n</code></pre></p>"},{"location":"DEMO_INSTRUCTIONS/#understanding-the-results","title":"\ud83d\udcda Understanding the Results","text":""},{"location":"DEMO_INSTRUCTIONS/#geographic-level-comparison","title":"Geographic Level Comparison","text":"<p>Block Groups (Traditional) - ~1,500 people per unit - Neighborhood-level precision - More processing time - Better for local community analysis</p> <p>ZCTAs (New Feature) - ~30,000 people per unit - ZIP code-level aggregation - Faster processing - Better for regional/mailing analysis</p>"},{"location":"DEMO_INSTRUCTIONS/#census-data-interpretation","title":"Census Data Interpretation","text":"<p>The census totals will differ between levels because: - Scale: ZCTAs cover larger areas - Boundaries: Different aggregation methods - Use Cases: Choose based on your analysis needs</p>"},{"location":"DEMO_INSTRUCTIONS/#next-steps","title":"\ud83c\udf89 Next Steps","text":"<p>After successful demo:</p> <ol> <li>Try your own data: Replace demo coordinates with your POIs</li> <li>Experiment with variables: Add more census variables</li> <li>Compare travel times: Test 10, 15, 30 minute scenarios  </li> <li>Integrate workflows: Use CSV outputs in your analysis tools</li> </ol>"},{"location":"DEMO_INSTRUCTIONS/#need-help","title":"\ud83d\udcde Need Help?","text":"<p>If the demo fails:</p> <ol> <li>Check requirements: Python 3.8+, required packages installed</li> <li>Verify installation: <code>python -c \"import socialmapper; print('OK')\"</code></li> <li>Internet access: Needed for Census API calls</li> <li>Coordinates: Ensure US locations only</li> </ol> <p>Still stuck? Check the detailed README: <code>ZCTA_DEMO_README.md</code></p> <p>\ud83c\udfaf Ready to test? Run <code>python demo_zcta_feature.py</code> and explore the new ZCTA capabilities! </p>"},{"location":"DOCUMENTATION_AUDIT/","title":"Documentation Audit Report","text":""},{"location":"DOCUMENTATION_AUDIT/#summary","title":"Summary","text":"<p>This audit identifies documentation issues following the removal of AI/ML, satellite, community detection, Plotly, and Streamlit features from SocialMapper.</p>"},{"location":"DOCUMENTATION_AUDIT/#1-references-to-removed-features-found","title":"1. References to Removed Features Found","text":""},{"location":"DOCUMENTATION_AUDIT/#files-with-references-to-removed-features","title":"Files with References to Removed Features:","text":"<ol> <li>docs/getting-started/installation.md</li> <li>Line 83: References <code>[ai]</code> extra in development installation</li> <li> <p>Lines 82-83: <code>pip install -e .[dev,ai]</code></p> </li> <li> <p>docs/CHANGELOG.md</p> </li> <li>Contains historical references to removed features in version history</li> <li> <p>This is appropriate as it documents historical changes</p> </li> <li> <p>docs/ARCHITECTURE.md</p> </li> <li>Clean - focuses on current ETL architecture</li> <li> <p>No references to removed features</p> </li> <li> <p>docs/REFACTORING_SUMMARY.md</p> </li> <li>Clean - documents core architecture improvements</li> <li> <p>No references to removed features</p> </li> <li> <p>Other documentation files</p> </li> <li>Various historical references in release notes and migration guides</li> <li>These are appropriate as they document the evolution of the project</li> </ol>"},{"location":"DOCUMENTATION_AUDIT/#2-missing-documentation-files","title":"2. Missing Documentation Files","text":"<p>The following files are referenced in mkdocs.yml but do not exist:</p>"},{"location":"DOCUMENTATION_AUDIT/#getting-started-section","title":"Getting Started Section","text":"<ul> <li><code>getting-started/quick-start.md</code></li> </ul>"},{"location":"DOCUMENTATION_AUDIT/#user-guide-section","title":"User Guide Section","text":"<ul> <li><code>user-guide/index.md</code></li> <li><code>user-guide/configuration.md</code></li> <li><code>user-guide/data-sources.md</code></li> <li><code>user-guide/features.md</code></li> </ul>"},{"location":"DOCUMENTATION_AUDIT/#tutorials-section","title":"Tutorials Section","text":"<ul> <li><code>tutorials/index.md</code></li> <li><code>tutorials/basic-usage.md</code></li> <li><code>tutorials/advanced-mapping.md</code></li> <li><code>tutorials/custom-analysis.md</code></li> </ul>"},{"location":"DOCUMENTATION_AUDIT/#examples-section","title":"Examples Section","text":"<ul> <li><code>examples/index.md</code></li> </ul>"},{"location":"DOCUMENTATION_AUDIT/#integrations-section","title":"Integrations Section","text":"<ul> <li><code>integrations/index.md</code></li> <li><code>integrations/address-geocoding.md</code></li> <li><code>integrations/osm-features.md</code></li> </ul>"},{"location":"DOCUMENTATION_AUDIT/#api-reference-section","title":"API Reference Section","text":"<ul> <li><code>api/index.md</code></li> <li><code>api/core.md</code></li> <li><code>api/data.md</code></li> <li><code>api/utilities.md</code></li> </ul>"},{"location":"DOCUMENTATION_AUDIT/#development-section","title":"Development Section","text":"<ul> <li><code>development/index.md</code></li> <li><code>development/contributing.md</code></li> <li><code>development/architecture.md</code></li> <li><code>development/releases.md</code></li> </ul>"},{"location":"DOCUMENTATION_AUDIT/#about-section","title":"About Section","text":"<ul> <li><code>about/index.md</code></li> <li><code>about/license.md</code></li> </ul>"},{"location":"DOCUMENTATION_AUDIT/#3-missing-required-directoriesfiles","title":"3. Missing Required Directories/Files","text":""},{"location":"DOCUMENTATION_AUDIT/#mkdocs-theme-requirements","title":"MkDocs Theme Requirements","text":"<ul> <li><code>docs/_static/</code> directory (referenced in mkdocs.yml custom_dir)</li> <li><code>docs/includes/abbreviations/abbreviations.md</code> (referenced in markdown_extensions)</li> </ul>"},{"location":"DOCUMENTATION_AUDIT/#existing-asset-files","title":"Existing Asset Files","text":"<ul> <li><code>docs/assets/css/extra.css</code> - exists</li> <li><code>docs/assets/js/extra.js</code> - exists</li> </ul>"},{"location":"DOCUMENTATION_AUDIT/#4-documentation-structure-issues","title":"4. Documentation Structure Issues","text":""},{"location":"DOCUMENTATION_AUDIT/#current-state","title":"Current State","text":"<p>The documentation has many placeholder references in mkdocs.yml but most documentation pages don't exist. This creates a poor user experience with broken links.</p>"},{"location":"DOCUMENTATION_AUDIT/#recommendations","title":"Recommendations","text":"<ol> <li>Immediate Actions:</li> <li>Remove <code>[ai]</code> reference from installation.md</li> <li>Either create the missing documentation files or update mkdocs.yml to only reference existing files</li> <li>Create the missing <code>_static</code> directory for the Material theme custom_dir</li> <li> <p>Create the <code>includes/abbreviations/abbreviations.md</code> file or remove the reference</p> </li> <li> <p>Documentation Focus:    The documentation should emphasize:</p> </li> <li>Core demographic and accessibility analysis</li> <li>ETL pipeline for community data</li> <li>Travel time isochrone generation</li> <li>Census data integration</li> <li>Static map generation</li> <li>POI (Points of Interest) discovery</li> <li> <p>Export capabilities for further analysis</p> </li> <li> <p>Streamlined Navigation:    Consider simplifying the navigation structure to match available documentation:    <pre><code>nav:\n  - Home: index.md\n  - Getting Started:\n    - getting-started/index.md\n    - Installation: getting-started/installation.md\n    - Demo: DEMO_INSTRUCTIONS.md\n  - Features:\n    - Address Geocoding: ADDRESS_GEOCODING.md\n    - OSMnx Integration: OSMNX_FEATURES.md\n  - Architecture: ARCHITECTURE.md\n  - Development:\n    - Refactoring Summary: REFACTORING_SUMMARY.md\n  - Changelog: CHANGELOG.md\n</code></pre></p> </li> </ol>"},{"location":"DOCUMENTATION_AUDIT/#5-content-that-aligns-with-streamlined-focus","title":"5. Content That Aligns with Streamlined Focus","text":"<p>The following documentation properly reflects the streamlined focus: - Main index.md - emphasizes demographic analysis and accessibility - ARCHITECTURE.md - describes ETL pipeline approach - REFACTORING_SUMMARY.md - documents core improvements - ADDRESS_GEOCODING.md - core geocoding feature - OSMNX_FEATURES.md - network analysis capabilities</p>"},{"location":"DOCUMENTATION_AUDIT/#next-steps","title":"Next Steps","text":"<ol> <li>Update mkdocs.yml to reference only existing documentation</li> <li>Remove references to <code>[ai]</code> extra from installation guide</li> <li>Create minimal missing directories (_static, includes)</li> <li>Consider creating essential missing documentation pages or removing their references</li> <li>Ensure all documentation emphasizes the core mission: demographic and accessibility analysis</li> </ol>"},{"location":"OSMNX_FEATURES/","title":"OSMnx 2.0+ Features Summary for SocialMapper","text":"<p>Date: June 7, 2025 OSMnx Version Tested: 2.0.3 Python Version: 3.13.3  </p>"},{"location":"OSMNX_FEATURES/#key-improvements-in-osmnx-20","title":"\ud83d\ude80 Key Improvements in OSMnx 2.0+","text":""},{"location":"OSMNX_FEATURES/#1-performance-memory-efficiency","title":"1. Performance &amp; Memory Efficiency","text":"<ul> <li>\u2705 Faster graph creation: Network for Corvallis, OR created in ~1 second</li> <li>\u2705 Improved memory management: Better handling of large datasets</li> <li>\u2705 Enhanced caching: More efficient network requests and data reuse</li> <li>\u2705 Optimized algorithms: Better computational efficiency across the board</li> </ul>"},{"location":"OSMNX_FEATURES/#2-enhanced-geometries-module","title":"2. Enhanced Geometries Module","text":"<ul> <li>\u2705 Multiple geometry types: Downloaded 102 POIs, 18,752 buildings, 98 parks efficiently</li> <li>\u2705 Better error handling: More robust data retrieval from OpenStreetMap</li> <li>\u2705 Improved integration: Better compatibility with GeoPandas/Shapely 2.0</li> <li>\u2705 Faster downloads: Cached results and optimized queries</li> </ul>"},{"location":"OSMNX_FEATURES/#3-advanced-network-analysis","title":"3. Advanced Network Analysis","text":"<ul> <li>\u2705 Multiple network types: Walk, drive, bike networks with better type handling</li> <li>\u2705 Centrality calculations: Betweenness and closeness centrality analysis</li> <li>\u2705 Street orientation analysis: Tools for urban form analysis</li> <li>\u2705 Large networks: Processed 15K+ nodes efficiently</li> </ul>"},{"location":"OSMNX_FEATURES/#4-enhanced-routing-features","title":"4. Enhanced Routing Features","text":"<ul> <li>\u2705 Multiple routing algorithms: Shortest path, fastest path, Dijkstra</li> <li>\u2705 Travel time integration: Easy addition of speed and travel time attributes</li> <li>\u2705 Sub-millisecond routing: Very fast path calculations</li> <li>\u2705 Multiple weight options: Length, time, or custom weights</li> </ul>"},{"location":"OSMNX_FEATURES/#5-spatial-analysis-isochrones","title":"5. Spatial Analysis &amp; Isochrones","text":"<ul> <li>\u2705 Accessibility analysis: 15-minute walking isochrones from POIs</li> <li>\u2705 Network coverage: Calculate reachable portions of street networks</li> <li>\u2705 Multi-modal analysis: Different transport modes supported</li> <li>\u2705 Geographic accuracy: Precise spatial calculations</li> </ul>"},{"location":"OSMNX_FEATURES/#6-enhanced-visualization","title":"6. Enhanced Visualization","text":"<ul> <li>\u2705 Modern styling: Beautiful figure-ground network visualizations</li> <li>\u2705 Customizable plots: Control over colors, styles, and layouts</li> <li>\u2705 High-quality outputs: Vector and raster format support</li> <li>\u2705 Interactive capabilities: Better integration with mapping libraries</li> </ul>"},{"location":"OSMNX_FEATURES/#7-type-annotations-error-handling","title":"7. Type Annotations &amp; Error Handling","text":"<ul> <li>\u2705 Full type hints: Better IDE support and code quality</li> <li>\u2705 Improved validation: Better input checking and error messages</li> <li>\u2705 Consistent API: Streamlined function names and parameters</li> <li>\u2705 Better debugging: Enhanced error reporting and logging</li> </ul>"},{"location":"OSMNX_FEATURES/#benefits-for-socialmapper-v050","title":"\ud83c\udfd8\ufe0f Benefits for SocialMapper v0.5.0","text":""},{"location":"OSMNX_FEATURES/#performance-improvements","title":"Performance Improvements","text":"Metric Improvement POI Discovery Faster OpenStreetMap queries with better caching Network Creation ~1 second for medium-sized cities Memory Usage More efficient handling of large datasets Batch Processing Better reliability for multiple locations"},{"location":"OSMNX_FEATURES/#enhanced-accuracy","title":"Enhanced Accuracy","text":"<ul> <li>Intersection Consolidation: Better handling of complex intersections</li> <li>Network Simplification: More accurate representation of street networks  </li> <li>Geometric Precision: Improved spatial calculations and projections</li> <li>Travel Time Calculation: More accurate accessibility analysis</li> </ul>"},{"location":"OSMNX_FEATURES/#new-capabilities","title":"New Capabilities","text":"<ul> <li>Building Footprints: Access to detailed urban morphology data</li> <li>Multi-modal Networks: Walk, drive, bike network analysis</li> <li>Advanced Centrality: Network analysis for community connectivity</li> <li>Enhanced Routing: Multiple pathfinding algorithms</li> </ul>"},{"location":"OSMNX_FEATURES/#integration-with-socialmapper","title":"\ud83d\udee0\ufe0f Integration with SocialMapper","text":""},{"location":"OSMNX_FEATURES/#immediate-benefits","title":"Immediate Benefits","text":"<ol> <li>Faster POI Discovery: Reduced time for finding community resources</li> <li>Better Demographics Mapping: More accurate intersection handling</li> <li>Enhanced Visualization: Better maps and network representations</li> <li>Improved Reliability: Better error handling for production use</li> </ol>"},{"location":"OSMNX_FEATURES/#future-opportunities","title":"Future Opportunities","text":"<ol> <li>Multi-modal Analysis: Walking, driving, cycling accessibility</li> <li>Building-level Analysis: Demographics at building footprint level</li> <li>Network Centrality: Identify key community connection points</li> <li>Advanced Isochrones: More sophisticated accessibility modeling</li> </ol>"},{"location":"OSMNX_FEATURES/#performance-metrics-from-demo","title":"\u26a1 Performance Metrics from Demo","text":"Operation Time Details Graph Creation 1.01s Corvallis drive network (1,862 nodes, 4,911 edges) Geometry Download &lt;1s each POIs, buildings, parks Betweenness Centrality 2.43s 15K+ node pedestrian network Routing &lt;0.002s Multiple algorithms Visualization &lt;5s High-quality network plot"},{"location":"OSMNX_FEATURES/#key-features-for-community-analysis","title":"\ud83c\udfaf Key Features for Community Analysis","text":""},{"location":"OSMNX_FEATURES/#what-socialmapper-gains","title":"What SocialMapper Gains","text":"<ul> <li>Speed: 2-5x faster data processing</li> <li>Scale: Handle larger cities and regions</li> <li>Accuracy: Better geometric and network precision</li> <li>Features: Access to building footprints, multi-modal networks</li> <li>Reliability: Production-ready error handling</li> </ul>"},{"location":"OSMNX_FEATURES/#research-planning-applications","title":"Research &amp; Planning Applications","text":"<ul> <li>Urban Form Analysis: Street pattern and orientation studies</li> <li>Accessibility Modeling: Multi-modal community resource access</li> <li>Network Analysis: Identify critical infrastructure connections</li> <li>Demographics Mapping: Building-level population analysis</li> </ul>"},{"location":"OSMNX_FEATURES/#next-steps","title":"\ud83d\ude80 Next Steps","text":"<ol> <li>Integration: Incorporate OSMnx 2.0+ features into SocialMapper core</li> <li>Testing: Validate performance improvements across different city sizes</li> <li>Features: Explore building footprint integration for demographics</li> <li>Documentation: Update guides with new capabilities</li> </ol> <p>Conclusion: OSMnx 2.0+ represents a major leap forward in geospatial network analysis, providing SocialMapper with cutting-edge capabilities for community mapping and demographic analysis. The combination of performance improvements, new features, and better reliability makes this upgrade essential for modern community analytics. </p>"},{"location":"REFACTORING_SUMMARY/","title":"SocialMapper Core Architecture: Final Clean Solution","text":""},{"location":"REFACTORING_SUMMARY/#problem-solved","title":"Problem Solved \u2705","text":"<p>The original architecture had two overlapping core files that created confusion and maintenance burden. This has been completely resolved with a single, well-organized file.</p>"},{"location":"REFACTORING_SUMMARY/#final-architecture","title":"Final Architecture","text":"<pre><code>core.py (735 lines) - Single, Organized File\n\u251c\u2500\u2500 \ud83d\udccb Module Documentation &amp; Imports\n\u251c\u2500\u2500 \ud83d\udd27 Pipeline Helper Functions (ETL Components)\n\u2502   \u251c\u2500\u2500 parse_custom_coordinates()\n\u2502   \u251c\u2500\u2500 setup_pipeline_environment()\n\u2502   \u251c\u2500\u2500 extract_poi_data()\n\u2502   \u251c\u2500\u2500 validate_poi_coordinates()\n\u2502   \u251c\u2500\u2500 generate_isochrones()\n\u2502   \u251c\u2500\u2500 integrate_census_data()\n\u2502   \u251c\u2500\u2500 export_pipeline_outputs()\n\u2502   \u2514\u2500\u2500 generate_final_report()\n\u251c\u2500\u2500 \ud83d\udee0\ufe0f Core Utility Functions\n\u2502   \u251c\u2500\u2500 setup_directory()\n\u2502   \u2514\u2500\u2500 convert_poi_to_geodataframe()\n\u2514\u2500\u2500 \ud83c\udfaf Main Pipeline Orchestration\n    \u2514\u2500\u2500 run_socialmapper() - The main API entry point\n</code></pre>"},{"location":"REFACTORING_SUMMARY/#key-benefits-achieved","title":"Key Benefits Achieved","text":""},{"location":"REFACTORING_SUMMARY/#eliminated-code-duplication","title":"\u2705 Eliminated Code Duplication","text":"<ul> <li>Before: Two files with overlapping functionality (769 + 568 lines)</li> <li>After: One organized file (735 lines) with clear structure</li> </ul>"},{"location":"REFACTORING_SUMMARY/#applied-software-engineering-best-practices","title":"\u2705 Applied Software Engineering Best Practices","text":"<ul> <li>Single Responsibility Principle: Each function does one thing well</li> <li>ETL Pattern: Clear Extract \u2192 Transform \u2192 Load phases</li> <li>Modular Design: Functions are focused and testable</li> <li>Clean Code: Logical organization with clear section headers</li> </ul>"},{"location":"REFACTORING_SUMMARY/#maintained-full-backward-compatibility","title":"\u2705 Maintained Full Backward Compatibility","text":"<ul> <li>Zero breaking changes for existing users</li> <li>All function signatures preserved</li> <li>Same API: <code>run_socialmapper()</code> unchanged</li> <li>No regressions in functionality</li> </ul>"},{"location":"REFACTORING_SUMMARY/#improved-maintainability","title":"\u2705 Improved Maintainability","text":"<ul> <li>Clear Organization: Functions grouped by purpose with visual sections</li> <li>Easy Navigation: Section headers make finding code simple</li> <li>Testable Functions: Each pipeline phase can be tested independently</li> <li>Single Source of Truth: All core logic in one place</li> </ul>"},{"location":"REFACTORING_SUMMARY/#file-structure-after-cleanup","title":"File Structure After Cleanup","text":"<pre><code>socialmapper/\n\u251c\u2500\u2500 core.py                    \u2190 Single, well-organized core file\n\u251c\u2500\u2500 [other modules unchanged]  \u2190 No breaking changes to rest of codebase\n\u2514\u2500\u2500 [core_pipeline.py deleted] \u2190 Redundant file removed\n</code></pre>"},{"location":"REFACTORING_SUMMARY/#code-organization-strategy","title":"Code Organization Strategy","text":""},{"location":"REFACTORING_SUMMARY/#clear-section-headers","title":"\ud83d\udccb Clear Section Headers","text":"<pre><code># =============================================================================\n# PIPELINE HELPER FUNCTIONS (ETL Components)\n# =============================================================================\n\n# =============================================================================  \n# MAIN PIPELINE ORCHESTRATION FUNCTION\n# =============================================================================\n</code></pre>"},{"location":"REFACTORING_SUMMARY/#logical-function-order","title":"\ud83c\udfaf Logical Function Order","text":"<ol> <li>Helper Functions First: All supporting functions at the top</li> <li>Main Function Last: <code>run_socialmapper()</code> at the bottom for easy reference</li> <li>Import Dependencies: Only when needed, locally scoped</li> </ol>"},{"location":"REFACTORING_SUMMARY/#etl-best-practices","title":"\ud83d\udd27 ETL Best Practices","text":"<ul> <li>Extract: <code>extract_poi_data()</code> - Get data from sources</li> <li>Transform: <code>validate_poi_coordinates()</code>, <code>generate_isochrones()</code> - Process data  </li> <li>Load: <code>integrate_census_data()</code>, <code>export_pipeline_outputs()</code> - Output results</li> </ul>"},{"location":"REFACTORING_SUMMARY/#evolution-what-we-had-vs-what-we-built","title":"Evolution: What We Had vs. What We Built","text":""},{"location":"REFACTORING_SUMMARY/#original-problem-two-files","title":"\u274c Original Problem (Two Files)","text":"<pre><code>core.py (769 lines)           core_pipeline.py (568 lines)\n\u251c\u2500\u2500 Monolithic function       \u251c\u2500\u2500 Modular functions  \n\u251c\u2500\u2500 Hard to maintain          \u251c\u2500\u2500 ETL best practices\n\u251c\u2500\u2500 Hard to test              \u251c\u2500\u2500 Single responsibility\n\u2514\u2500\u2500 Legacy approach           \u2514\u2500\u2500 Modern approach\n\nProblems:\n- Code duplication between files\n- Developer confusion: which file to use?\n- Maintenance burden: changes in two places\n- Risk of versions diverging\n</code></pre>"},{"location":"REFACTORING_SUMMARY/#final-solution-one-file","title":"\u2705 Final Solution (One File)","text":"<pre><code>core.py (735 lines)\n\u251c\u2500\u2500 \ud83d\udd27 Modular ETL Functions\n\u2502   \u251c\u2500\u2500 Focused responsibilities\n\u2502   \u251c\u2500\u2500 Easy to test independently  \n\u2502   \u251c\u2500\u2500 Clear error handling\n\u2502   \u2514\u2500\u2500 Modern Python practices\n\u2514\u2500\u2500 \ud83c\udfaf Clean Orchestration\n    \u251c\u2500\u2500 Simple function calls\n    \u251c\u2500\u2500 Clear parameter flow\n    \u251c\u2500\u2500 Backward compatibility\n    \u2514\u2500\u2500 Readable pipeline\n</code></pre>"},{"location":"REFACTORING_SUMMARY/#testing-status","title":"Testing Status \u2705","text":"<ul> <li>Import Compatibility: <code>from socialmapper.core import run_socialmapper</code> works</li> <li>Function Signatures: All original APIs preserved</li> <li>Zero Regressions: Functionality unchanged</li> <li>Memory Efficiency: Modular approach better than monolithic</li> </ul>"},{"location":"REFACTORING_SUMMARY/#why-this-is-the-optimal-solution","title":"Why This is the Optimal Solution","text":""},{"location":"REFACTORING_SUMMARY/#simplicity-over-complexity","title":"\ud83c\udfaf Simplicity Over Complexity","text":"<ul> <li>One file to rule them all: No confusion about which file to edit</li> <li>Clear organization: Visual sections make navigation easy</li> <li>Maintainable size: 735 lines is reasonable for a main module</li> </ul>"},{"location":"REFACTORING_SUMMARY/#engineering-excellence","title":"\ud83d\udee0\ufe0f Engineering Excellence","text":"<ul> <li>Modular functions: Each does one thing well</li> <li>Clean separation: ETL phases clearly defined</li> <li>Error handling: Better isolation of issues</li> <li>Performance: Optimized memory usage</li> </ul>"},{"location":"REFACTORING_SUMMARY/#developer-experience","title":"\ud83d\udc65 Developer Experience","text":"<ul> <li>No ambiguity: Only one place to find core logic</li> <li>Easy onboarding: Clear structure for new developers</li> <li>Debugging: Issues isolated to specific functions</li> <li>Testing: Functions can be tested independently</li> </ul>"},{"location":"REFACTORING_SUMMARY/#code-quality-improvements","title":"Code Quality Improvements","text":""},{"location":"REFACTORING_SUMMARY/#before-monolithic","title":"Before (Monolithic):","text":"<pre><code>def run_socialmapper(...):\n    # 700+ lines of everything mixed together\n    setup_directories()\n    parse_coordinates() \n    query_osm()\n    validate_data()\n    generate_isochrones()\n    get_census_data()\n    export_results()\n    # ... all in one giant function\n</code></pre>"},{"location":"REFACTORING_SUMMARY/#after-modular","title":"After (Modular):","text":"<pre><code>def run_socialmapper(...):\n    # Clean orchestration of focused functions\n    directories = setup_pipeline_environment(...)\n    poi_data, base_filename, states, sampled = extract_poi_data(...)\n    validate_poi_coordinates(poi_data)\n    isochrones = generate_isochrones(poi_data, travel_time, states)\n    blocks, census, codes = integrate_census_data(isochrones, vars, key, poi_data)\n    results = export_pipeline_outputs(census, poi_data, ...)\n    return generate_final_report(poi_data, sampled, results, ...)\n</code></pre>"},{"location":"REFACTORING_SUMMARY/#future-development-made-easy","title":"Future Development Made Easy \ud83d\ude80","text":"<p>With this solid foundation: - \u2705 Add new pipeline phases without touching existing code - \u2705 Optimize individual functions independently - \u2705 Better monitoring per pipeline stage - \u2705 A/B test different algorithms in isolation - \u2705 Clear extension points for new features</p> <p>Result: A single, beautifully organized core file that follows modern software engineering practices while maintaining complete backward compatibility. </p>"},{"location":"RELEASE_NOTES_v0.5.2/","title":"SocialMapper v0.5.2 Release Notes","text":""},{"location":"RELEASE_NOTES_v0.5.2/#breaking-changes-upgrades","title":"\ud83d\udd27 Breaking Changes &amp; Upgrades","text":""},{"location":"RELEASE_NOTES_v0.5.2/#pydantic-v2-migration-complete","title":"Pydantic v2 Migration Complete","text":"<p>SocialMapper has been fully upgraded to Pydantic v2, bringing improved performance and modern validation patterns.</p> <p>What was upgraded: - All <code>@validator</code> decorators migrated to <code>@field_validator</code> with <code>@classmethod</code> - Updated coordinate validation models in <code>socialmapper.util.coordinate_validation</code> - Maintained full backward compatibility for end users</p> <p>Technical Details: - <code>CoordinatePoint</code>, <code>POICoordinate</code>, and <code>CoordinateCluster</code> models now use Pydantic v2 syntax - All field validators properly migrated and tested - No API changes for end users - models work exactly the same - Enhanced validation performance from Pydantic v2's Rust-based core</p> <p>Files Modified: - <code>socialmapper/util/coordinate_validation.py</code> - Validator syntax updated - Version bumped to 0.5.2</p>"},{"location":"RELEASE_NOTES_v0.5.2/#testing","title":"\ud83e\uddea Testing","text":"<p>All coordinate validation models have been thoroughly tested and verified to work correctly with the new Pydantic v2 syntax.</p>"},{"location":"RELEASE_NOTES_v0.5.2/#developer-notes","title":"\ud83d\udcda Developer Notes","text":"<p>If you're extending SocialMapper with custom Pydantic models, please use the new v2 syntax:</p> <pre><code># New Pydantic v2 syntax\nfrom pydantic import BaseModel, field_validator\n\nclass MyModel(BaseModel):\n    my_field: str\n\n    @field_validator('my_field')\n    @classmethod\n    def validate_my_field(cls, v):\n        # validation logic\n        return v\n</code></pre>"},{"location":"RELEASE_NOTES_v0.5.2/#dependencies","title":"\ud83d\udd17 Dependencies","text":"<ul> <li>Pydantic: <code>&gt;=2.0.0</code> (already required in previous versions)</li> <li>All other dependencies remain unchanged</li> </ul> <p>Full Changelog: v0.5.1...v0.5.2 </p>"},{"location":"RELEASE_NOTES_v0.5.3/","title":"SocialMapper v0.5.3 Release Notes","text":""},{"location":"RELEASE_NOTES_v0.5.3/#critical-bug-fixes","title":"\ud83d\udd27 Critical Bug Fixes","text":""},{"location":"RELEASE_NOTES_v0.5.3/#census-api-configuration-resolution","title":"Census API Configuration Resolution","text":"<p>Issue Resolved: Cold cache demos were failing due to Census API key configuration problems that prevented fresh installations from working properly.</p> <p>Root Cause:  - Typo in <code>.env</code> file: <code>CENSUS_APY_KEY</code> instead of <code>CENSUS_API_KEY</code> - <code>get_census_api_key()</code> function caused Streamlit secrets errors in non-Streamlit environments</p> <p>Fix Implemented: 1. \u2705 Fixed .env configuration - Corrected typo to use proper <code>CENSUS_API_KEY</code> environment variable 2. \u2705 Enhanced <code>get_census_api_key()</code> function in <code>socialmapper/util/__init__.py</code>:    - Prioritizes environment variables over Streamlit secrets    - Only attempts Streamlit secrets access when in actual Streamlit context    - Gracefully handles all Streamlit-related errors</p>"},{"location":"RELEASE_NOTES_v0.5.3/#validation-results","title":"\ud83d\udcca Validation Results","text":"<p>Cold Cache Demos Now Working: - \u2705 Simple Cold Cache Demo: 2.5x performance improvement (56.5s \u2192 22.6s) - \u2705 Comprehensive Cold Cache Demo: 4.9x performance improvement (50.6s \u2192 10.3s) - \u2705 Fresh installation workflow verified - \u2705 All APIs and data sources accessible - \u2705 Cache rebuild process working correctly</p> <p>Demo Suite Status: - \u2705 Rich UI Demo - Beautiful terminal interface - \u2705 Neighbor API Usage - Geographic relationships with 96% storage savings - \u2705 Fuquay-Varina Case Study - Real-world application - \u2705 OSMnx 2.0+ Features - Advanced geospatial capabilities - \u2705 Address Geocoding Demo - Modern geocoding with multiple providers - \u2705 Cold Cache Demos - NOW WORKING after fixes</p>"},{"location":"RELEASE_NOTES_v0.5.3/#impact","title":"\ud83c\udfaf Impact","text":"<p>This release resolves a critical blocking issue that prevented: - New installations from accessing Census data - Cold cache testing and validation - Fresh deployment workflows - Demo suite completion</p>"},{"location":"RELEASE_NOTES_v0.5.3/#technical-details","title":"\ud83d\udd17 Technical Details","text":"<p>Files Modified: - <code>socialmapper/util/__init__.py</code> - Enhanced Census API key loading logic - <code>.env</code> - Fixed typo in environment variable name</p> <p>Backward Compatibility: - \u2705 Fully backward compatible - \u2705 No API changes - \u2705 No breaking changes</p>"},{"location":"RELEASE_NOTES_v0.5.3/#next-steps","title":"\ud83d\ude80 Next Steps","text":"<p>With this fix, SocialMapper v0.5.3 is now production-ready for: - Fresh installations and deployments - Cold cache scenarios (containers, new environments) - Complete demo suite execution - Robust Census data integration</p> <p>Recommended Action: Upgrade immediately if experiencing Census API connectivity issues or cold cache demo failures.</p> <p>This release ensures SocialMapper works reliably across all deployment scenarios and completes the v0.5.x feature set. </p>"},{"location":"migration-guide/","title":"Migration Guide: SocialMapper v0.5.x to v0.6.0","text":"<p>This guide helps you migrate from the old SocialMapper API to the new modern API introduced in v0.5.4.</p>"},{"location":"migration-guide/#overview","title":"Overview","text":"<p>The new API provides: - \u2705 Better error handling with Result types - \u2705 Cleaner configuration with builder pattern - \u2705 Async support for better performance - \u2705 Type safety throughout - \u2705 Proper resource management with context managers</p>"},{"location":"migration-guide/#quick-migration-examples","title":"Quick Migration Examples","text":""},{"location":"migration-guide/#basic-analysis","title":"Basic Analysis","text":"<p>Old API (Deprecated): <pre><code>from socialmapper import run_socialmapper\n\nresult = run_socialmapper(\n    geocode_area=\"San Francisco\",\n    state=\"CA\",\n    poi_type=\"amenity\",\n    poi_name=\"library\",\n    travel_time=15,\n    census_variables=[\"total_population\", \"median_income\"]\n)\n</code></pre></p> <p>New API (Recommended): <pre><code>from socialmapper.api import quick_analysis\n\nresult = quick_analysis(\n    location=\"San Francisco, CA\",\n    poi_search=\"amenity:library\",\n    travel_time=15,\n    census_variables=[\"total_population\", \"median_income\"]\n)\n\nif result.is_ok():\n    analysis = result.unwrap()\n    print(f\"Found {analysis.poi_count} libraries\")\n</code></pre></p>"},{"location":"migration-guide/#custom-pois","title":"Custom POIs","text":"<p>Old API: <pre><code>result = run_socialmapper(\n    custom_coords_path=\"locations.csv\",\n    travel_time=20,\n    census_variables=[\"total_population\"],\n    export_maps=True\n)\n</code></pre></p> <p>New API: <pre><code>from socialmapper.api import analyze_custom_pois\n\nresult = analyze_custom_pois(\n    \"locations.csv\",\n    travel_time=20,\n    census_variables=[\"total_population\"],\n    enable_maps=True\n)\n</code></pre></p>"},{"location":"migration-guide/#advanced-configuration","title":"Advanced Configuration","text":"<p>Old API: <pre><code>from socialmapper import run_socialmapper\n\nresult = run_socialmapper(\n    geocode_area=\"Chicago\",\n    state=\"Illinois\",\n    poi_type=\"leisure\",\n    poi_name=\"park\",\n    travel_time=20,\n    geographic_level=\"zcta\",\n    census_variables=[\"total_population\", \"median_income\", \"median_age\"],\n    export_csv=True,\n    export_maps=True,\n    export_isochrones=True,\n    map_backend=\"matplotlib\",\n    output_dir=\"chicago_parks\"\n)\n</code></pre></p> <p>New API: <pre><code>from socialmapper.api import SocialMapperClient, SocialMapperBuilder, GeographicLevel\n\nconfig = (SocialMapperBuilder()\n    .with_location(\"Chicago\", \"Illinois\")\n    .with_osm_pois(\"leisure\", \"park\")\n    .with_travel_time(20)\n    .with_geographic_level(GeographicLevel.ZCTA)\n    .with_census_variables(\"total_population\", \"median_income\", \"median_age\")\n    .enable_map_export()\n    .enable_isochrone_export()\n    .with_output_directory(\"chicago_parks\")\n    .build()\n)\n\nwith SocialMapperClient() as client:\n    result = client.run_analysis(config)\n\n    match result:\n        case Ok(analysis):\n            print(f\"Success! Analyzed {analysis.census_units_analyzed} census units\")\n        case Err(error):\n            print(f\"Error: {error.message}\")\n</code></pre></p>"},{"location":"migration-guide/#using-runconfig","title":"Using RunConfig","text":"<p>Old API: <pre><code>from socialmapper import run_socialmapper, RunConfig\n\nconfig = RunConfig(\n    custom_coords_path=\"pois.json\",\n    travel_time=15,\n    census_variables=[\"total_population\"],\n    export_maps=True\n)\n\nresult = run_socialmapper(config)\n</code></pre></p> <p>New API: <pre><code>from socialmapper.api import SocialMapperClient, SocialMapperBuilder\n\nconfig = (SocialMapperBuilder()\n    .with_custom_pois(\"pois.json\")\n    .with_travel_time(15)\n    .with_census_variables(\"total_population\")\n    .enable_map_export()\n    .build()\n)\n\nwith SocialMapperClient() as client:\n    result = client.run_analysis(config)\n</code></pre></p>"},{"location":"migration-guide/#error-handling","title":"Error Handling","text":""},{"location":"migration-guide/#old-api","title":"Old API","text":"<p>The old API raises exceptions that need to be caught:</p> <pre><code>try:\n    result = run_socialmapper(...)\nexcept ValueError as e:\n    print(f\"Error: {e}\")\nexcept Exception as e:\n    print(f\"Unexpected error: {e}\")\n</code></pre>"},{"location":"migration-guide/#new-api","title":"New API","text":"<p>The new API returns Result types for explicit error handling:</p> <pre><code>result = client.analyze(...)\n\n# Option 1: Pattern matching (Python 3.10+)\nmatch result:\n    case Ok(analysis):\n        print(f\"Success: {analysis.poi_count} POIs\")\n    case Err(error):\n        print(f\"Failed: {error}\")\n\n# Option 2: Traditional if/else\nif result.is_ok():\n    analysis = result.unwrap()\n    print(f\"Success: {analysis.poi_count} POIs\")\nelse:\n    error = result.unwrap_err()\n    print(f\"Failed: {error}\")\n</code></pre>"},{"location":"migration-guide/#async-operations","title":"Async Operations","text":"<p>The new API supports async operations for better performance:</p> <pre><code>import asyncio\nfrom socialmapper.api import AsyncSocialMapper\n\nasync def analyze_async():\n    config = {...}  # Your configuration\n\n    async with AsyncSocialMapper(config) as mapper:\n        # Stream POIs as they're found\n        async for poi in mapper.stream_pois():\n            print(f\"Found: {poi.name}\")\n\n        # Run full analysis\n        result = await mapper.run_analysis()\n        return result\n\n# Run async function\nresult = asyncio.run(analyze_async())\n</code></pre>"},{"location":"migration-guide/#parameter-mapping","title":"Parameter Mapping","text":"Old Parameter New Method/Parameter <code>geocode_area</code> + <code>state</code> <code>.with_location(city, state)</code> <code>poi_type</code> + <code>poi_name</code> <code>.with_osm_pois(type, name)</code> <code>custom_coords_path</code> <code>.with_custom_pois(path)</code> <code>travel_time</code> <code>.with_travel_time(minutes)</code> <code>census_variables</code> <code>.with_census_variables(*vars)</code> <code>geographic_level</code> <code>.with_geographic_level(level)</code> <code>export_maps=True</code> <code>.enable_map_export()</code> <code>export_isochrones=True</code> <code>.enable_isochrone_export()</code> <code>export_csv=False</code> <code>.disable_csv_export()</code> <code>output_dir</code> <code>.with_output_directory(path)</code> <code>max_poi_count</code> <code>.limit_pois(count)</code>"},{"location":"migration-guide/#deprecation-timeline","title":"Deprecation Timeline","text":"<ul> <li>v0.5.4: New API introduced, deprecation warnings added</li> <li>v0.6.0: <code>run_socialmapper</code> moved to legacy module</li> <li>v0.7.0: Old API completely removed</li> </ul>"},{"location":"migration-guide/#getting-help","title":"Getting Help","text":"<p>If you encounter issues during migration:</p> <ol> <li>Check the API documentation</li> <li>See examples/modern_api_demo.py</li> <li>Report issues on GitHub</li> </ol>"},{"location":"migration-guide/#benefits-of-migrating","title":"Benefits of Migrating","text":"<ol> <li>Better Error Handling: No more mysterious exceptions</li> <li>Type Safety: Full IDE support with autocompletion</li> <li>Cleaner Code: Intuitive builder pattern</li> <li>Better Performance: Async support for I/O operations</li> <li>Future Proof: Active development on new API only</li> </ol>"},{"location":"getting-started/","title":"Getting Started with SocialMapper","text":"<p>Welcome to SocialMapper! This section will help you get up and running quickly with community demographic analysis and mapping.</p>"},{"location":"getting-started/#quick-navigation","title":"Quick Navigation","text":""},{"location":"getting-started/#installation","title":"\ud83d\ude80 Installation","text":"<p>Learn how to install SocialMapper and its dependencies on your system.</p>"},{"location":"getting-started/#quick-start-guide","title":"\u26a1 Quick Start Guide","text":"<p>Follow a step-by-step tutorial to create your first community analysis.</p>"},{"location":"getting-started/#demo-instructions","title":"\ud83c\udfac Demo Instructions","text":"<p>Interactive demonstrations and examples to explore SocialMapper's capabilities.</p>"},{"location":"getting-started/#choose-your-path","title":"Choose Your Path","text":"I'm New to ProgrammingI'm a Python DeveloperI'm a Researcher/Analyst <p>Start here if you're new to Python or programming:</p> <ol> <li>Follow the Installation Guide for Python setup</li> <li>Run the Demo Instructions for guided examples</li> <li>Explore command line examples in the main README</li> <li>Try the Python API for programmatic access</li> </ol> <p>Jump right in if you're comfortable with Python:</p> <ol> <li><code>pip install socialmapper</code> - Quick installation</li> <li>Check the Quick Start Guide - 5-minute tutorial</li> <li>Explore API Reference for advanced usage</li> <li>Read Architecture Overview for system design</li> </ol> <p>Focus on analysis capabilities:</p> <ol> <li>Review Use Cases to understand applications</li> <li>Try Demo Instructions with sample data</li> <li>Learn Configuration Options</li> <li>Explore Address Geocoding Features</li> </ol>"},{"location":"getting-started/#what-youll-learn","title":"What You'll Learn","text":"<p>By the end of this section, you'll be able to:</p> <ul> <li>\u2705 Install and configure SocialMapper</li> <li>\u2705 Run your first community analysis  </li> <li>\u2705 Understand input data requirements</li> <li>\u2705 Generate maps and export results</li> <li>\u2705 Navigate the documentation effectively</li> </ul>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.8+ (Python 3.11+ recommended)</li> <li>Basic command line familiarity (helpful but not required)</li> <li>Geographic data interest (no GIS experience needed)</li> </ul>"},{"location":"getting-started/#support","title":"Support","text":"<p>Need help getting started?</p> <ul> <li>\ud83d\udcd6 Read the docs - This documentation covers most scenarios</li> <li>\ud83d\ude80 Try the examples - Run demo scripts in examples/ directory</li> <li>\ud83d\udc1b Report issues - GitHub Issues</li> <li>\ud83d\udcac Ask questions - Create a GitHub discussion</li> </ul> <p>Ready to begin? Start with Installation or jump to the Quick Start Guide! </p>"},{"location":"getting-started/installation/","title":"Installation Guide","text":"<p>This guide covers multiple ways to install SocialMapper depending on your needs and experience level.</p>"},{"location":"getting-started/installation/#quick-installation","title":"Quick Installation","text":"pip (Recommended)uv (Modern &amp; Fast)conda <pre><code>pip install socialmapper\n</code></pre> <pre><code># Install uv if you don't have it\npip install uv\n\n# Install SocialMapper\nuv add socialmapper\n</code></pre> <pre><code># Add conda-forge channel if not already added\nconda config --add channels conda-forge\n\n# Install SocialMapper\nconda install socialmapper\n</code></pre>"},{"location":"getting-started/installation/#system-requirements","title":"System Requirements","text":""},{"location":"getting-started/installation/#python-version","title":"Python Version","text":"<ul> <li>Python 3.11+ (minimum required)</li> <li>Python 3.12 (recommended for best performance)</li> <li>Python 3.13 (latest, fully supported)</li> </ul>"},{"location":"getting-started/installation/#operating-systems","title":"Operating Systems","text":"<ul> <li>\u2705 Windows 10/11</li> <li>\u2705 macOS 10.15+ (Intel and Apple Silicon)</li> <li>\u2705 Linux (Ubuntu 20.04+, CentOS 8+, and others)</li> </ul>"},{"location":"getting-started/installation/#hardware-recommendations","title":"Hardware Recommendations","text":"<ul> <li>RAM: 4GB minimum, 8GB+ recommended</li> <li>Storage: 1GB free space (for cache and outputs)</li> <li>Internet: Required for data downloads</li> </ul>"},{"location":"getting-started/installation/#installation-options","title":"Installation Options","text":""},{"location":"getting-started/installation/#option-1-standard-installation","title":"Option 1: Standard Installation","text":"<p>For most users, the standard installation provides all core features:</p> <pre><code>pip install socialmapper\n</code></pre>"},{"location":"getting-started/installation/#option-2-development-installation-with-enhanced-features","title":"Option 2: Development Installation with Enhanced Features","text":"<p>For development work and extended functionality:</p> <pre><code>pip install socialmapper[dev]\n</code></pre> <p>This includes additional dependencies for: - \ud83d\udd27 Development tools (testing, linting, formatting) - \ud83d\udcca Enhanced analysis capabilities - \ud83c\udfa8 Rich terminal UI features</p>"},{"location":"getting-started/installation/#option-3-development-installation","title":"Option 3: Development Installation","text":"<p>For contributors and developers:</p> <pre><code># Clone the repository\ngit clone https://github.com/mihiarc/socialmapper.git\ncd socialmapper\n\n# Install in development mode with all dependencies\npip install -e .[dev]\n</code></pre>"},{"location":"getting-started/installation/#option-4-minimal-installation","title":"Option 4: Minimal Installation","text":"<p>Note: The <code>[minimal]</code> extra is not currently available. The standard installation already provides a lightweight experience.</p>"},{"location":"getting-started/installation/#dependency-management","title":"Dependency Management","text":""},{"location":"getting-started/installation/#using-uv-recommended","title":"Using uv (Recommended)","text":"<p>According to a memory from a past conversation, you should use 'uv' as the package management tool for installing and managing Python dependencies in this project instead of pip.</p> <pre><code># Install uv\npip install uv\n\n# Create a new project with SocialMapper\nuv init my-socialmapper-project\ncd my-socialmapper-project\nuv add socialmapper\n\n# Or add to existing project\nuv add socialmapper\n</code></pre>"},{"location":"getting-started/installation/#using-pip-with-virtual-environments","title":"Using pip with virtual environments","text":"<pre><code># Create virtual environment\npython -m venv socialmapper-env\n\n# Activate (Windows)\nsocialmapper-env\\Scripts\\activate\n\n# Activate (macOS/Linux)\nsource socialmapper-env/bin/activate\n\n# Install SocialMapper\npip install socialmapper\n</code></pre>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<p>Test your installation with these commands:</p> <pre><code># Check version\npython -c \"import socialmapper; print(socialmapper.__version__)\"\n\n# Run help command\nsocialmapper --help\n\n# Quick test (requires internet)\npython -c \"from socialmapper import run_socialmapper; print('\u2705 Installation successful!')\"\n</code></pre>"},{"location":"getting-started/installation/#optional-api-keys","title":"Optional: API Keys","text":"<p>While SocialMapper works without API keys, some features are enhanced with them:</p>"},{"location":"getting-started/installation/#census-bureau-api-key-recommended","title":"Census Bureau API Key (Recommended)","text":"<ul> <li>Benefit: Faster census data downloads</li> <li>Get key: Census API Registration</li> <li>Setup: <code>export CENSUS_API_KEY=\"your_key_here\"</code></li> </ul>"},{"location":"getting-started/installation/#google-maps-api-key-optional","title":"Google Maps API Key (Optional)","text":"<ul> <li>Benefit: Enhanced geocoding accuracy</li> <li>Get key: Google Cloud Console</li> <li>Setup: <code>export GOOGLE_MAPS_API_KEY=\"your_key_here\"</code></li> </ul>"},{"location":"getting-started/installation/#common-installation-issues","title":"Common Installation Issues","text":""},{"location":"getting-started/installation/#issue-no-module-named-socialmapper","title":"Issue: \"No module named 'socialmapper'\"","text":"<p>Solution: <pre><code># Ensure you're in the right environment\nwhich python\npip list | grep socialmapper\n\n# Reinstall if needed\npip uninstall socialmapper\npip install socialmapper\n</code></pre></p>"},{"location":"getting-started/installation/#issue-dependency-conflicts","title":"Issue: Dependency conflicts","text":"<p>Solution: Use a fresh virtual environment: <pre><code>python -m venv fresh-env\nsource fresh-env/bin/activate  # or fresh-env\\Scripts\\activate on Windows\npip install socialmapper\n</code></pre></p>"},{"location":"getting-started/installation/#issue-networkssl-errors","title":"Issue: Network/SSL errors","text":"<p>Solution: Update certificates and try again: <pre><code># macOS\n/Applications/Python\\ 3.x/Install\\ Certificates.command\n\n# Or use trusted hosts\npip install --trusted-host pypi.org --trusted-host pypi.python.org socialmapper\n</code></pre></p>"},{"location":"getting-started/installation/#issue-permission-errors-linuxmacos","title":"Issue: Permission errors (Linux/macOS)","text":"<p>Solution: Use user installation: <pre><code>pip install --user socialmapper\n</code></pre></p>"},{"location":"getting-started/installation/#issue-missing-system-dependencies-linux","title":"Issue: Missing system dependencies (Linux)","text":"<p>Solution: Install system packages: <pre><code># Ubuntu/Debian\nsudo apt-get update\nsudo apt-get install python3-dev python3-pip build-essential\n\n# CentOS/RHEL\nsudo yum install python3-devel python3-pip gcc\n</code></pre></p>"},{"location":"getting-started/installation/#platform-specific-notes","title":"Platform-Specific Notes","text":""},{"location":"getting-started/installation/#windows","title":"Windows","text":"<ul> <li>Use Command Prompt or PowerShell (avoid Git Bash for installation)</li> <li>Consider Windows Subsystem for Linux (WSL) for a Linux-like experience</li> <li>Visual Studio Build Tools may be needed for some dependencies</li> </ul>"},{"location":"getting-started/installation/#macos","title":"macOS","text":"<ul> <li>Xcode Command Line Tools required: <code>xcode-select --install</code></li> <li>Homebrew recommended for Python management: <code>brew install python</code></li> <li>Apple Silicon (M1/M2): All dependencies are compatible</li> </ul>"},{"location":"getting-started/installation/#linux","title":"Linux","text":"<ul> <li>Most distributions include Python, but you may need <code>python3-pip</code></li> <li>GDAL and spatial libraries are included in the package</li> <li>Build tools (<code>gcc</code>, <code>make</code>) may be required</li> </ul>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>After successful installation:</p> <ol> <li>\ud83d\udcd6 Read the Quick Start Guide</li> <li>\ud83c\udfac Try the Demo Instructions</li> <li>\ud83d\udcbb Run the Example Scripts</li> <li>\ud83d\udd27 Configure your API keys (optional)</li> </ol>"},{"location":"getting-started/installation/#getting-help","title":"Getting Help","text":"<p>If you encounter issues:</p> <ol> <li>\ud83d\udcda Check this documentation</li> <li>\ud83d\udd0d Search GitHub Issues</li> <li>\ud83d\udc1b Report new issues with:</li> <li>Your Python version (<code>python --version</code>)</li> <li>Your OS and version</li> <li>Complete error messages</li> <li>Installation method used</li> </ol> <p>Ready to start? Continue to the Quick Start Guide! </p>"},{"location":"getting-started/quick-start/","title":"Quick Start Guide","text":"<p>Get up and running with SocialMapper in minutes! This guide will walk you through your first analysis.</p>"},{"location":"getting-started/quick-start/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11 or higher installed</li> <li>Internet connection for downloading data</li> <li>(Optional) Census API key for enhanced data</li> </ul>"},{"location":"getting-started/quick-start/#installation","title":"Installation","text":"<pre><code>pip install socialmapper\n</code></pre>"},{"location":"getting-started/quick-start/#your-first-analysis","title":"Your First Analysis","text":"<p>Let's analyze library accessibility in a community:</p>"},{"location":"getting-started/quick-start/#1-basic-command-line-usage","title":"1. Basic Command Line Usage","text":"<pre><code>socialmapper analyze --state \"North Carolina\" --county \"Wake County\" \\\n  --place-type \"library\" --travel-time 15\n</code></pre>"},{"location":"getting-started/quick-start/#2-python-script","title":"2. Python Script","text":"<p>Create a file <code>my_first_analysis.py</code>:</p> <pre><code>from socialmapper import run_socialmapper\n\n# Analyze library accessibility\nresults = run_socialmapper(\n    state=\"North Carolina\",\n    county=\"Wake County\",\n    place_type=\"library\",\n    travel_time=15,\n    census_variables=[\"total_population\", \"median_household_income\"],\n    export_csv=True\n)\n\n# Display results\nprint(f\"Found {len(results['poi_data'])} libraries\")\nprint(f\"Analyzed {len(results['census_data'])} census block groups\")\n</code></pre> <p>Run it: <pre><code>python my_first_analysis.py\n</code></pre></p>"},{"location":"getting-started/quick-start/#understanding-the-results","title":"Understanding the Results","text":"<p>After running the analysis, you'll get:</p> <ol> <li>POI Data - Information about each library found</li> <li>Census Data - Demographics of areas within travel time</li> <li>CSV Files - Detailed data exported to <code>output/csv/</code></li> <li>Maps (optional) - Visualizations in <code>output/maps/</code></li> </ol>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":""},{"location":"getting-started/quick-start/#try-different-poi-types","title":"Try Different POI Types","text":"<pre><code># Schools\nresults = run_socialmapper(\n    state=\"California\",\n    county=\"Los Angeles County\",\n    place_type=\"school\",\n    travel_time=10\n)\n\n# Healthcare facilities\nresults = run_socialmapper(\n    state=\"Texas\",\n    county=\"Harris County\",\n    place_type=\"hospital\",\n    travel_time=20\n)\n</code></pre>"},{"location":"getting-started/quick-start/#use-custom-locations","title":"Use Custom Locations","text":"<p>Create a CSV file <code>my_locations.csv</code>: <pre><code>name,latitude,longitude\nCommunity Center,35.7796,-78.6382\nCity Park,35.7821,-78.6589\n</code></pre></p> <p>Then analyze: <pre><code>results = run_socialmapper(\n    custom_coords_path=\"my_locations.csv\",\n    travel_time=15,\n    census_variables=[\"total_population\"]\n)\n</code></pre></p>"},{"location":"getting-started/quick-start/#add-more-census-variables","title":"Add More Census Variables","text":"<pre><code># Detailed demographic analysis\ncensus_vars = [\n    \"total_population\",\n    \"median_age\",\n    \"median_household_income\",\n    \"percent_poverty\",\n    \"percent_without_vehicle\"\n]\n\nresults = run_socialmapper(\n    state=\"New York\",\n    county=\"New York County\",\n    place_type=\"park\",\n    travel_time=10,\n    census_variables=census_vars\n)\n</code></pre>"},{"location":"getting-started/quick-start/#common-patterns","title":"Common Patterns","text":""},{"location":"getting-started/quick-start/#batch-analysis","title":"Batch Analysis","text":"<pre><code># Analyze multiple POI types\npoi_types = ['library', 'school', 'hospital', 'park']\n\nfor poi_type in poi_types:\n    print(f\"\\nAnalyzing {poi_type}s...\")\n    results = run_socialmapper(\n        state=\"Washington\",\n        county=\"King County\",\n        place_type=poi_type,\n        travel_time=15\n    )\n    print(f\"Found {len(results['poi_data'])} {poi_type}s\")\n</code></pre>"},{"location":"getting-started/quick-start/#different-travel-times","title":"Different Travel Times","text":"<pre><code># Compare accessibility at different time intervals\nfor minutes in [5, 10, 15, 20, 30]:\n    results = run_socialmapper(\n        state=\"Colorado\",\n        county=\"Denver County\",\n        place_type=\"grocery_store\",\n        travel_time=minutes\n    )\n    total_pop = sum(r['total_population'] for r in results['census_data'])\n    print(f\"{minutes} minutes: {total_pop:,} people\")\n</code></pre>"},{"location":"getting-started/quick-start/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/quick-start/#no-results-found","title":"No Results Found?","text":"<ul> <li>Check spelling of state/county names</li> <li>Try a different POI type</li> <li>Ensure internet connection is active</li> </ul>"},{"location":"getting-started/quick-start/#slow-performance","title":"Slow Performance?","text":"<ul> <li>First runs build caches (normal)</li> <li>Reduce number of census variables</li> <li>Use smaller geographic areas</li> </ul>"},{"location":"getting-started/quick-start/#memory-issues","title":"Memory Issues?","text":"<ul> <li>Process one county at a time</li> <li>Limit census variables</li> <li>Close other applications</li> </ul>"},{"location":"getting-started/quick-start/#learn-more","title":"Learn More","text":"<ul> <li>Examples Directory - Complete working examples</li> <li>API Documentation - Detailed function reference</li> <li>Command Line Guide - All CLI options</li> <li>Data Sources - Understanding the data</li> </ul> <p>Ready for more? Check out our tutorials for step-by-step guides!</p>"}]}